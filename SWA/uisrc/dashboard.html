<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SWA V2 - Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="stylesheet" href="dashboard.cs2s" />
    <style>
        :root {
    --primary: #0066ff;
    --primary-hover: #005ae0;
    --text: #f1f1f1;
    --text-secondary: #a0a0a0;
    --border: rgba(255, 255, 255, 0.1);
    --card-bg: rgba(20, 20, 20, 0.7);
    --title-bar-bg: rgba(15, 15, 15, 0.9);
    --close-btn-hover: #e81123;
    --minimize-btn-hover: #333333;
    --danger: #e74c3c;
    --danger-hover: #c0392b;
    --success: #2ecc71;
    --warning: #f39c12;
}

/* Make all elements unselectable */
* {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: var(--text);
}

/* Chrome, Safari, Opera */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
    background: transparent;
}

::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.1);
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.2);
}

/* Main Container */
.dashboard-container {
    width: 800px;
    height: 600px;
    position: relative;
    overflow: hidden;
    margin: 0 auto;
    background: rgba(20, 20, 20, 0.7);
}

/* Title Bar */
.title-bar {
    height: 32px;
    background-color: var(--title-bar-bg);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 12px;
    
    user-select: none;
    border-bottom: 1px solid var(--border);
    box-sizing: border-box;
}

.title-bar-text {
    color: var(--text-secondary);
    font-size: 14px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 8px;
}

.title-bar-text i {
    color: var(--primary);
    font-size: 16px;
}

/* Plan Badge */
.plan-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 10px;
    font-weight: 600;
    color: #111;
    margin-left: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    text-shadow: 0px 1px 0px rgba(255, 255, 255, 0.2);
}

.plan-badge.premium {
    background: linear-gradient(135deg, #FFD700, #FFA500);
    border: 1px solid rgba(255, 215, 0, 0.5);
}

.plan-badge.admin {
    background: linear-gradient(135deg, #FF416C, #FF4B2B);
    border: 1px solid rgba(255, 65, 108, 0.5);
}

.plan-badge.standard {
    background: linear-gradient(135deg, #007bff, #6610f2);
    border: 1px solid rgba(0, 123, 255, 0.5);
}

.window-controls {
    display: flex;
    align-items: center;
}

.window-control {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: transparent;
    border-radius: 4px;
    color: var(--text-secondary);
    font-size: 10px;
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease;
    margin-left: 6px;
    outline: none;
}

.window-control:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.window-control.minimize:hover {
    background-color: var(--minimize-btn-hover);
    color: white;
}

.window-control.close:hover {
    background-color: var(--close-btn-hover);
    color: white;
}

/* Main Content Layout */
.dashboard-content {
    display: flex;
    height: calc(100% - 32px); /* Full height minus title bar */
}

/* Sidebar */
.sidebar {
    width: 200px;
    height: 100%;
    background-color: rgba(15, 15, 15, 0.8);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.user-profile {
    padding: 20px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 12px;
}

.avatar {
    width: 40px;
    height: 40px;
    background-color: var(--primary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
}

.user-info {
    overflow: hidden;
}

.username {
    font-size: 16px;
    font-weight: 600;
    margin: 0;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.user-plan {
    font-size: 12px;
    color: var(--primary);
    display: block;
    margin-top: 2px;
}

.main-nav {
    flex: 1;
    padding: 15px 0;
    overflow-y: auto;
}

.main-nav ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.nav-item {
    display: flex;
    align-items: center;
    padding: 12px 20px;
    cursor: pointer;
    color: var(--text-secondary);
    transition: all 0.2s ease;
    gap: 10px;
}

.nav-item i {
    width: 24px;
    font-size: 16px;
    text-align: center;
}

.nav-item:hover {
    background-color: rgba(255, 255, 255, 0.05);
    color: var(--text);
}

.nav-item.active {
    background-color: rgba(0, 102, 255, 0.1);
    color: var(--primary);
    border-left: 3px solid var(--primary);
    padding-left: 17px; /* 20px - 3px border */
}

/* Ad Banner Container */
.ad-banner-container {
    align-items: center;
    gap: 8px;
    margin: 10px 4px;
    padding: 0;
}

.ad-banner-container.visible {
    display: flex;
}

.banner-nav-btn {
    background: rgba(30, 30, 30, 0.8);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    width: 24px;
    height: 24px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.banner-nav-btn:hover {
    background: rgba(46, 204, 113, 0.2);
    border-color: var(--primary);
    color: var(--primary);
}

.banner-nav-btn i {
    font-size: 10px;
}

/* Rotating Banner */
.rotating-banner {
    flex: 1;
    border-radius: 10px;
    overflow: hidden;
    cursor: pointer;
    position: relative;
    height: 80px;
    background: linear-gradient(135deg, rgba(30, 30, 35, 0.95), rgba(20, 20, 25, 0.95));
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    transition: all 0.3s ease;
}

.rotating-banner:hover {
    border-color: rgba(255, 255, 255, 0.15);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
}

.banner-slide {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 10px;
    padding: 15px 15px 20px 15px;
    opacity: 0;
    transform: scale(0.95);
    transition: opacity 0.5s ease, transform 0.5s ease;
    pointer-events: none;
}

.banner-slide.active {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}

.banner-icon {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    position: relative;
    overflow: hidden;
}

/* Icon colors will be set dynamically via inline styles from API */

.banner-icon i {
    font-size: 20px;
    color: #ffffff;
    z-index: 2;
}

.banner-info {
    display: flex;
    flex-direction: column;
    gap: 1px;
    text-align: left;
}

.banner-label {
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--text-secondary);
    font-weight: 600;
}

.banner-name {
    font-size: 16px;
    font-weight: 700;
    color: var(--text);
    letter-spacing: 0.3px;
    line-height: 1;
}

.banner-desc {
    font-size: 11px;
    color: var(--text-secondary);
    font-weight: 500;
}

/* Banner Dots */
.banner-dots {
    position: absolute;
    bottom: 8px;
    right: 12px;
    display: flex;
    gap: 6px;
    z-index: 10;
}

.banner-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3);
    cursor: pointer;
    transition: all 0.3s ease;
}

.banner-dot:hover {
    background: rgba(255, 255, 255, 0.5);
}

.banner-dot.active {
    background: var(--primary);
    width: 18px;
    border-radius: 3px;
}

.bottom-nav {
    border-top: 1px solid var(--border);
    padding: 15px 0;
}

/* Content Area */
.content-area {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    position: relative;
}

.page-content {
    display: none;
    animation: fadeIn 0.3s ease forwards;
}

.page-content.active {
    display: block;
}

.page-content h2 {
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 10px;
    color: var(--text);
}

.page-content p {
    color: var(--text-secondary);
    margin-bottom: 20px;
    font-size: 14px;
}

/* Home Page */
.stats-cards {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-top: 30px;
}

.stat-card {
    background-color: rgba(30, 30, 30, 0.7);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    transition: all 0.2s ease;
}

.stat-card:hover {
    transform: translateY(-2px);
    border-color: var(--primary);
    box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
}

.stat-card i {
    font-size: 24px;
    color: var(--primary);
    background-color: rgba(0, 102, 255, 0.1);
    padding: 12px;
    border-radius: 6px;
}

.stat-info h3 {
    font-size: 14px;
    color: var(--text-secondary);
    margin: 0;
}

.stat-value {
    font-size: 22px;
    font-weight: 700;
    color: var(--text);
}

/* Simple Empty State */
.empty-state {
    min-height: 300px;
    margin-top: 20px;
}

.empty-state-container {
    background: var(--card-bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 40px;
    text-align: center;
    color: var(--text-secondary);
    width: 100%;
    box-sizing: border-box;
}

.empty-state-container i {
    font-size: 48px;
    margin-bottom: 20px;
    opacity: 0.4;
    color: var(--text-secondary);
    display: block;
}

.empty-state-container p {
    font-size: 16px;
    margin: 0;
    color: var(--text-secondary);
}

/* Settings Page */
.settings-section {
    background-color: rgba(30, 30, 30, 0.4);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 20px;
    margin-bottom: 30px;
}

.settings-section h3 {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 15px;
    color: var(--text);
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border);
}

.setting-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 0;
    border-bottom: 1px solid var(--border);
}

.setting-item:last-child {
    border-bottom: none;
}

.setting-info {
    display: flex;
    flex-direction: column;
}

.setting-name {
    font-size: 14px;
    color: var(--text);
    margin-bottom: 4px;
}

.setting-description {
    font-size: 12px;
    color: var(--text-secondary);
}

/* Toggle Switch */
.toggle-switch {
    position: relative;
    width: 46px;
    height: 24px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-switch label {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #333;
    transition: .4s;
    border-radius: 24px;
}

.toggle-switch label:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

.toggle-switch input:checked + label {
    background-color: var(--primary);
}

.toggle-switch input:checked + label:before {
    transform: translateX(22px);
}

/* Buttons */
.danger-btn {
    background-color: rgba(231, 76, 60, 0.2);
    color: var(--danger);
    border: 1px solid rgba(231, 76, 60, 0.3);
    border-radius: 4px;
    padding: 6px 12px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.danger-btn:hover {
    background-color: var(--danger);
    color: white;
}

.secondary-btn {
    background-color: rgba(255, 255, 255, 0.05);
    color: var(--text-secondary);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
}

.secondary-btn:hover {
    background-color: rgba(255, 255, 255, 0.1);
    color: var(--text);
    border-color: var(--text-secondary);
}

/* Warning Badge */
.warning-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    background-color: rgba(255, 152, 0, 0.15);
    color: #ff9800;
    border: 1px solid rgba(255, 152, 0, 0.3);
    border-radius: 6px;
    padding: 6px 12px;
    font-size: 13px;
    font-weight: 500;
    cursor: help;
    transition: all 0.2s ease;
    position: relative;
}

.warning-badge:hover {
    background-color: rgba(255, 152, 0, 0.25);
    border-color: #ff9800;
    transform: scale(1.02);
}

.warning-badge i {
    font-size: 13px;
}

/* Custom Tooltip */
.custom-tooltip {
    position: fixed;
    background: linear-gradient(135deg, rgba(20, 20, 22, 0.98) 0%, rgba(15, 15, 17, 0.98) 100%);
    border: 1px solid rgba(255, 152, 0, 0.4);
    border-radius: 8px;
    padding: 18px 20px;
    width: 480px;
    max-width: 480px;
    z-index: 10000;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 152, 0, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.custom-tooltip.show {
    opacity: 1;
}

.custom-tooltip-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(255, 152, 0, 0.2);
}

.custom-tooltip-header i {
    color: #ff9800;
    font-size: 16px;
}

.custom-tooltip-title {
    color: #ff9800;
    font-weight: 600;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.custom-tooltip-content {
    color: var(--text-secondary);
    font-size: 13px;
    line-height: 1.6;
}

.custom-tooltip-content p {
    margin: 0 0 10px 0;
}

.custom-tooltip-content p:last-child {
    margin-bottom: 0;
}

.custom-tooltip-content strong {
    color: var(--text);
    font-weight: 600;
}

/* Account Info */
.account-info {
    margin-bottom: 20px;
}

.info-item {
    display: flex;
    padding: 8px 0;
}

.info-label {
    width: 100px;
    color: var(--text-secondary);
    font-size: 14px;
}

.info-value {
    color: var(--text);
    font-size: 14px;
    font-weight: 500;
}

.logout-btn {
    background-color: transparent;
    color: var(--danger);
    border: 1px solid var(--danger);
    border-radius: 4px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
    justify-content: center;
    margin-top: 10px;
}

.logout-btn:hover {
    background-color: var(--danger);
    color: white;
}

/* Debug Info Section */
.debug-info {
    padding: 20px;
}

.info-item {
    margin-bottom: 20px;
}

.info-label {
    display: block;
    font-weight: 500;
    margin-bottom: 8px;
    color: var(--text);
}

.info-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.info-header .info-label {
    font-size: 18px;
    margin-bottom: 0;
    color: var(--text);
    font-weight: 500;
    letter-spacing: 0.5px;
}

.info-value {
    display: block;
    color: var(--text-secondary);
    word-break: break-all;
}

/* Error Console Styles */
.console-controls {
    display: flex;
    align-items: center;
    gap: 15px;
    margin: 15px 0;
    background: rgba(25, 25, 25, 0.6);
    padding: 12px;
    border-radius: 6px;
    border: 1px solid var(--border);
}

.console-controls .primary-btn,
.console-controls .secondary-btn {
    margin: 0;
    padding: 8px 16px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    border-radius: 4px;
    flex-shrink: 0;
}

.console-controls .primary-btn {
    background-color: rgba(0, 102, 255, 0.3);
    border: 1px solid rgba(0, 102, 255, 0.4);
}

.console-controls .secondary-btn {
    background-color: rgba(120, 120, 120, 0.2);
    border: 1px solid rgba(120, 120, 120, 0.3);
}

.toggle-container {
    display: flex;
    align-items: center;
    margin-left: auto;
    padding: 6px 12px;
    border-radius: 4px;
    background: rgba(0, 102, 255, 0.15);
    border: 1px solid rgba(0, 102, 255, 0.2);
}

.toggle-input {
    margin-right: 8px;
    width: 16px;
    height: 16px;
    accent-color: var(--primary);
}

.toggle-container label {
    color: var(--text);
    font-size: 13px;
    white-space: nowrap;
}

.console-container {
    position: relative;
    width: 100%;
    height: 300px;
    background-color: rgba(10, 10, 10, 0.9);
    border: 1px solid rgba(60, 60, 60, 0.5);
    border-radius: 6px;
    overflow: hidden;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
}

.error-console {
    width: 100%;
    height: 100%;
    overflow-y: auto;
    padding: 20px;
    margin: 0;
    color: #e0e0e0;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.6;
    white-space: normal;
    word-wrap: break-word;
    word-break: normal;
    letter-spacing: 0.3px;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    /* Make console text selectable */
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
    cursor: text;
}

/* Make sure children elements in the console are also selectable */
.error-console * {
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
    cursor: text;
}

/* Highlight selected text in the console */
.error-console::selection,
.error-console *::selection {
    background-color: rgba(0, 102, 255, 0.4);
    color: white;
}

/* Colorize certain log entries */
.error-console .error {
    color: #ff5252;
}

.error-console .warning {
    color: #ffb142;
}

.error-console .success {
    color: #2ed573;
}

/* Toggle files list */
.primary-btn {
    background-color: rgba(0, 102, 255, 0.2);
    color: var(--primary);
    border: 1px solid rgba(0, 102, 255, 0.3);
    border-radius: 4px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 10px;
}

.primary-btn:hover {
    background-color: var(--primary);
    color: white;
}

.primary-btn i {
    font-size: 14px;
}

/* Repair Plugin Button */
.repair-plugin-btn {
    background-color: rgba(255, 153, 0, 0.15);
    color: #ff9900;
    border: 1px solid rgba(255, 153, 0, 0.3);
    border-radius: 4px;
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 32px;
    height: 28px;
}

.repair-plugin-btn:hover {
    background-color: rgba(255, 153, 0, 0.25);
    border-color: #ff9900;
    transform: scale(1.05);
}

.repair-plugin-btn i {
    font-size: 13px;
}

/* Custom Select Dropdown */
.custom-select {
    position: relative;
    width: 120px;
}

.custom-select-trigger {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 14px;
    color: var(--text);
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    width: 100%;
}

.custom-select-trigger:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: var(--primary);
}

.custom-select-trigger i {
    font-size: 12px;
    color: var(--text-secondary);
    transition: transform 0.2s ease;
}

.custom-select.open .custom-select-trigger i {
    transform: rotate(180deg);
}

.custom-select-options {
    position: absolute;
    top: calc(100% + 4px);
    right: 0;
    width: 280px;
    background: rgba(30, 30, 35, 0.98);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 4px;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transform: translateY(-10px);
    transition: all 0.2s ease;
    backdrop-filter: blur(10px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

.custom-select.open .custom-select-options {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.custom-select-option {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.custom-select-option:hover {
    background: rgba(0, 102, 255, 0.15);
}

.custom-select-option i {
    font-size: 18px;
    color: var(--primary);
    width: 24px;
    text-align: center;
}

.option-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.option-name-row {
    display: flex;
    align-items: center;
    gap: 8px;
}

.option-name {
    font-size: 14px;
    font-weight: 500;
    color: var(--text);
}

.option-badge {
    display: inline-block;
    font-size: 10px;
    font-weight: 600;
    color: var(--success);
    background: rgba(46, 204, 113, 0.15);
    padding: 2px 6px;
    border-radius: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.option-desc {
    font-size: 11px;
    color: var(--text-secondary);
}

/* Status Indicator */
.status-indicator {
    position: absolute;
    bottom: 10px;
    right: 10px;
    padding: 6px 12px;
    background-color: rgba(20, 20, 20, 0.8);
    border: 1px solid var(--border);
    border-radius: 20px;
    font-size: 12px;
    z-index: 10;
}

.status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.status i {
    font-size: 8px;
}

.status.enabled {
    color: var(--success);
}

.status.disabled {
    color: var(--text-secondary);
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Error console section specific styling */
.debug-section-console {
    background: rgba(20, 20, 20, 0.7);
    border-radius: 8px;
    border: 1px solid rgba(60, 60, 60, 0.4);
    padding: 20px;
    margin-top: 20px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

/* Timestamp styling in the console */
.error-console .timestamp {
    color: #727272;
    font-weight: 500;
}

/* Additional polish for error console */
.error-console::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

.error-console::-webkit-scrollbar-thumb {
    background: rgba(0, 102, 255, 0.3);
    border-radius: 5px;
}

.error-console::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 102, 255, 0.5);
}

.error-console::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
}

/* Console controls polish */
.console-controls .primary-btn:hover {
    background-color: rgba(0, 102, 255, 0.5);
    color: white;
}

.console-controls .secondary-btn:hover {
    background-color: rgba(120, 120, 120, 0.3);
    color: white;
}

/* Make the console header more distinct */
.debug-section-console .info-header {
    border-bottom-color: rgba(0, 102, 255, 0.2);
}

.debug-section-console .info-header .info-label {
    color: #ffffff;
}

.console-controls .primary-btn i,
.console-controls .secondary-btn i {
    margin-right: 6px;
}

/* Update notification and progress styling */
.update-info {
    display: flex;
    align-items: flex-start;
    gap: 20px;
    padding: 10px;
}

.update-icon {
    font-size: 36px;
    color: var(--primary);
    padding: 15px;
    background: rgba(0, 102, 255, 0.1);
    border-radius: 50%;
    flex-shrink: 0;
}

.update-details {
    flex: 1;
}

.version-comparison {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin: 15px 0;
    padding: 12px;
    background: rgba(10, 10, 10, 0.3);
    border-radius: 6px;
    border: 1px solid var(--border);
}

.current-version-label, 
.new-version-label {
    font-size: 14px;
    font-weight: 500;
}

.current-version-label {
    color: var(--text-secondary);
}

.new-version-label {
    color: var(--primary);
}

.update-description {
    font-size: 14px;
    color: var(--text-secondary);
    margin-top: 12px;
}

/* Progress bar styling */
.update-progress-container {
    padding: 20px 10px;
    text-align: center;
}

.progress-bar-container {
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--primary-hover), var(--primary));
    border-radius: 4px;
    transition: width 0.3s ease;
}

.progress-text {
    font-size: 14px;
    font-weight: 600;
    color: var(--primary);
    margin-bottom: 15px;
}

.progress-description {
    font-size: 14px;
    color: var(--text-secondary);
}

/* Version badge for title bar */
.version-badge {
    font-size: 10px;
    background: rgba(0, 102, 255, 0.2);
    color: var(--primary);
    padding: 2px 6px;
    border-radius: 10px;
    margin-left: 8px;
}

/* Animation for update notification */
@keyframes pulse-update {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.update-available-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    background-color: #2ecc71;
    border-radius: 50%;
    margin-left: 6px;
    animation: pulse-update 2s infinite;
} 
        /* Modern UI Variables */
        :root {
            --primary: #0066ff;
            --primary-gradient: linear-gradient(135deg, #0066ff, #0066ff);
            --primary-hover: #005ae0;
            --text: #f1f1f1;
            --text-secondary: #a0a0a0;
            --border: rgba(255, 255, 255, 0.1);
            --card-bg: rgba(20, 20, 20, 0.7);
            --card-hover: rgba(25, 25, 25, 0.8);
            --title-bar-bg: rgba(15, 15, 15, 0.9);
            --bg-gradient: linear-gradient(180deg, rgba(15, 15, 15, 0.9) 0%, rgba(12, 12, 12, 0.9) 100%);
            --sidebar-bg: rgba(15, 15, 15, 0.8);
            --close-btn-hover: #e81123;
            --minimize-btn-hover: #333333;
            --danger: #e74c3c;
            --danger-hover: #c0392b;
            --success: #2ecc71;
            --warning: #f39c12;
        }

        /* Game image modal styles */
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            backdrop-filter: blur(5px);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .image-modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .image-modal-content {
            background-color: var(--card-bg);
            border-radius: 8px;
            max-width: 90%;
            max-height: 90%;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }

        .image-modal-header {
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border);
        }

        .image-modal-title {
            font-size: 18px;
            font-weight: 500;
            color: var(--text);
            margin: 0;
        }

        .image-modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
        }

        .image-modal-close:hover {
            color: var(--text);
        }

        .image-modal-body {
            padding: 16px;
            overflow: auto;
            text-align: center;
        }

        .image-modal-body img {
            max-width: 100%;
            max-height: 70vh;
            border-radius: 4px;
            display: block;
            margin: 0 auto;
        }

        .image-modal-loading {
            color: var(--text-secondary);
            font-style: italic;
            padding: 30px;
            text-align: center;
        }

        .image-modal-error {
            color: var(--danger);
            padding: 20px;
            text-align: center;
            background-color: rgba(231, 76, 60, 0.1);
            border-radius: 4px;
            margin: 10px;
        }

        /* Catalog action buttons */
        .action-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .show-image-btn {
            background-color: var(--card-hover);
            color: var(--text);
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 13px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .show-image-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Game cards - No animations */
        .game-card.redesigned {
            display: flex;
            background: rgba(15, 15, 15, 0.7);
            border-radius: 12px;
            padding: 0;
            margin-bottom: 15px;
            border: 1px solid var(--border);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            height: 100px;
        }

        /* Action button in top right corner with consistent spacing */
        .action-corner {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 10;
            background: rgba(25, 25, 30, 0.7);
        }

        /* Update button in top right corner next to the action button */
        .update-action-btn {
            position: absolute;
            top: 12px;
            right: 46px; /* Position right after the action button */
            z-index: 10;
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.15), rgba(39, 174, 96, 0.15));
            border: 1px solid rgba(46, 204, 113, 0.4);
            font-size: 14px;
            padding: 8px;
            border-radius: 6px;
            color: #2ecc71;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 0 0 rgba(46, 204, 113, 0);
            backdrop-filter: blur(10px);
            width: 32px;
            height: 32px;
        }

        .update-action-btn:hover {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.25), rgba(39, 174, 96, 0.25));
            border-color: rgba(46, 204, 113, 0.6);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);
        }

        .update-action-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(46, 204, 113, 0.2);
        }

        .update-action-btn i {
            font-size: 13px;
        }

        /* Update game title row to horizontal layout */
        .game-card-header {
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            margin-bottom: 5px;
            padding-right: 35px; /* Make space for the action button */
            width: 100%;
        }
        
        /* Developer info under game title */
        .game-title-row {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            width: 100%;
            text-align: left;
        }

        .game-name {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
            color: #eaeaea;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 280px;
            line-height: 1.2;
            text-align: left;
        }
        
        .game-developer {
            font-size: 12px;
            color: #888;
            display: flex;
            align-items: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 280px;
            margin-top: -2px;
            text-align: left;
        }
        
        .game-developer i {
            display: none; /* Hide the users icon */
        }
        
        .game-developer.loaded {
            color: #888;
        }
        
        .game-developer.unknown {
            color: #777;
            font-style: italic;
        }
        
        /* ID in action menu */
        .game-id-display {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 5px;
            padding-top: 8px;
            color: #777;
            font-size: 12px;
        }
        
        .game-id-display i {
            color: #777;
        }

        .game-img-col {
            flex: 0 0 180px;
            height: 100%;
            position: relative;
            border-radius: 0;
            overflow: hidden;
            border: none;
        }

        .game-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Add a gradient overlay to the image */
        .game-img-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to right, 
                rgba(15, 15, 15, 0.9) 0%, 
                rgba(15, 15, 15, 0.6) 40%, 
                rgba(15, 15, 15, 0.2) 100%);
            pointer-events: none;
        }

        .game-info-col {
            flex: 1;
            padding: 12px 15px;
            margin-left: 0;
            display: flex;
            flex-direction: column;
            z-index: 2;
            justify-content: flex-start;
            align-items: flex-start;
            text-align: left;
        }

        .game-controls-col {
            width: 40px;
            display: flex;
            align-items: center;
            flex-direction: column;
            justify-content: center;
            gap: 8px;
            background: rgba(10, 10, 10, 0.4);
            border-left: 1px solid rgba(255, 255, 255, 0.05);
            padding: 0 10px;
        }

        /* Update button styling without animations */
        .update-btn {
            background: rgba(30, 30, 35, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .update-btn:hover {
            background: rgba(0, 102, 255, 0.2);
            color: var(--primary);
            border-color: rgba(0, 102, 255, 0.3);
        }

        /* Action toggle styling without animations */
        .action-toggle {
            background: rgba(30, 30, 35, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-toggle:hover {
            background: rgba(255, 255, 255, 0.08);
            color: white;
        }

        /* Meta tags styling */
        .game-meta-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
            max-width: 100%;
        }

        .meta-tag {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 4px;
            height: 22px;
            color: #aaaaaa;
        }

        .meta-tag i {
            margin-right: 6px;
            font-size: 11px;
            opacity: 0.9;
        }

        .meta-tag.genre {
            background-color: rgba(0, 102, 255, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(0, 102, 255, 0.2);
        }

        .meta-tag.developer {
            background-color: rgba(30, 30, 35, 0.6);
            color: #aaaaaa;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Other genre-specific styling */
        .meta-tag.action {
            background-color: rgba(0, 102, 255, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(0, 102, 255, 0.2);
        }

        .meta-tag.casual {
            background-color: rgba(46, 204, 113, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(46, 204, 113, 0.2);
        }

        .meta-tag.rpg {
            background-color: rgba(155, 89, 182, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(155, 89, 182, 0.2);
        }

        .meta-tag.adventure {
            background-color: rgba(241, 196, 15, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(241, 196, 15, 0.2);
        }

        /* DRM and Launcher badges on game image */
        .drm-badge,
        .launcher-badge {
            position: absolute;
            top: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 4;
            cursor: help;
            transition: all 0.2s ease;
        }

        .drm-badge {
            left: 8px;
            background-color: rgba(243, 156, 18, 0.2);
            color: #f39c12;
            border: 1px solid rgba(243, 156, 18, 0.6);
        }

        .drm-badge:hover {
            background-color: rgba(243, 156, 18, 0.3);
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(243, 156, 18, 0.4);
        }

        .launcher-badge {
            left: 42px;
            background-color: rgba(52, 152, 219, 0.2);
            color: #3498db;
            border: 1px solid rgba(52, 152, 219, 0.6);
        }

        .launcher-badge.first-badge {
            left: 8px;
        }

        .launcher-badge:hover {
            background-color: rgba(52, 152, 219, 0.3);
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
        }

        /* Custom tooltip for DRM/Launcher badges */
        .badge-tooltip {
            position: fixed;
            background: rgba(20, 20, 20, 0.95);
            color: var(--text);
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            max-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10002;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            line-height: 1.4;
        }

        .badge-tooltip.show {
            display: block;
            animation: fadeIn 0.2s ease;
        }

        .badge-tooltip-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text);
        }

        .badge-tooltip-content {
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
        }

        /* Score Badge with darker colors */
        .score-badge {
            position: absolute;
            bottom: 12px;
            left: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            z-index: 3;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        /* Consolidated score badge color classes with !important to ensure they're applied correctly */
        .score-high {
            background-color: rgba(46, 204, 113, 0.25) !important;
            color: #2ecc71 !important;
            border: 1px solid rgba(46, 204, 113, 0.4) !important;
        }

        .score-medium {
            background-color: rgba(243, 156, 18, 0.25) !important;
            color: #f39c12 !important;
            border: 1px solid rgba(243, 156, 18, 0.4) !important;
        }

        .score-low {
            background-color: rgba(231, 76, 60, 0.25) !important;
            color: #e74c3c !important;
            border: 1px solid rgba(231, 76, 60, 0.4) !important;
        }

        /* Disabled overlay */
        .disabled-game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            z-index: 6;
            pointer-events: none;
        }

        .disabled-game-text {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 18px;
            border-radius: 4px;
            transform: rotate(-5deg);
            letter-spacing: 1px;
            border: 1px solid rgba(30, 30, 35, 0.7);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease;
        }

        /* Remove date metadata tag styling since we don't show it anymore */
        .meta-tag.date {
            display: none;
        }

        .meta-tag.action {
            background-color: rgba(0, 102, 255, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(0, 102, 255, 0.2);
        }

        .meta-tag.casual {
            background-color: rgba(46, 204, 113, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(46, 204, 113, 0.2);
        }

        .meta-tag.rpg {
            background-color: rgba(155, 89, 182, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(155, 89, 182, 0.2);
        }

        .meta-tag.adventure {
            background-color: rgba(241, 196, 15, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(241, 196, 15, 0.2);
        }

        .metacritic-score {
            position: absolute;
            bottom: 12px;
            left: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 15px;
            z-index: 5;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .score-high {
            background-color: rgba(46, 204, 113, 0.25);
            color: #2ecc71;
            border: 1px solid rgba(46, 204, 113, 0.4);
        }

        .score-medium {
            background-color: rgba(243, 156, 18, 0.25);
            color: #f39c12;
            border: 1px solid rgba(243, 156, 18, 0.4);
        }

        .score-low {
            background-color: rgba(231, 76, 60, 0.25);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.4);
        }

        .game-img-loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary);
            font-size: 18px;
            border-radius: 0;
        }

        .meta-tag.loading {
            font-style: italic;
            opacity: 0.7;
        }

        .meta-tag.error {
            color: var(--danger);
            border-color: rgba(231, 76, 60, 0.3);
            background-color: rgba(231, 76, 60, 0.15);
        }

        .disabled-game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
            pointer-events: none;
        }

        .disabled-game-text {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 18px;
            border-radius: 4px;
            transform: rotate(-5deg);
            letter-spacing: 1px;
            border: 1px solid rgba(30, 30, 35, 0.7);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease;
        }

        .score-badge {
            position: absolute;
            bottom: 12px;
            left: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            z-index: 3;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        /* Add subtle animation to the action toggle */
        .action-toggle {
            transform-origin: center;
            transition: transform 0.2s ease, background-color 0.2s ease, color 0.2s ease;
        }

        .action-toggle:active {
            transform: scale(0.95);
        }

        /* Improved action toggle button */
        .game-controls-corner .action-toggle {
            background: rgba(45, 45, 50, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(2px);
        }

        .game-controls-corner .action-toggle:hover {
            background: rgba(60, 60, 65, 0.9);
            border-color: rgba(255, 255, 255, 0.15);
        }

        /* Highlight toggle button when menu is open */
        .action-menu.show + .action-toggle,
        .action-toggle:focus {
            background: linear-gradient(180deg, rgba(15, 15, 15, 0.9) 0%, rgba(12, 12, 12, 0.9) 100%) !important;
            color: var(--primary) !important;
            border-color: rgba(0, 102, 255, 0.5) !important;
        }

        /* Loading Overlay Styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a, #141414);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .loading-logo {
            font-size: 65px;
            color: var(--primary);
            margin-bottom: 30px;
            animation: pulse 2s infinite;
        }

        /* Log message in title bar */
        .log-message {
            font-size: 14px;
            font-weight: 400;
            color: var(--text-secondary);
            max-width: 350px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            opacity: 0.85;
            transition: opacity 0.3s ease;
            letter-spacing: 0.2px;
        }
        
        .log-message.success {
            color: #2ecc71;
        }
        
        .log-message.error {
            color: #e74c3c;
        }
        
        .log-message.warning {
            color: #f39c12;
        }
        
        .log-message.info {
            color: #3498db;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        .loading-progress-container {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .loading-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--primary-hover), var(--primary));
            border-radius: 10px;
            transition: width 0.5s ease;
            animation: progress-animation 2.5s ease-in-out;
        }

        @keyframes progress-animation {
            0% { width: 0%; }
            20% { width: 20%; }
            50% { width: 60%; }
            80% { width: 85%; }
            100% { width: 100%; }
        }

        .loading-text {
            color: var(--text);
            font-size: 16px;
            font-weight: 500;
            letter-spacing: 0.5px;
            margin-top: 15px;
        }

        .hidden {
            opacity: 0;
            visibility: hidden;
        }

        /* Hide dashboard content during loading */
        .dashboard-content {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .dashboard-content.loaded {
            opacity: 1;
            visibility: visible;
        }

        /* Connection Error Overlay */
        .connection-error-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0a0a, #2d1414);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .error-content {
            text-align: center;
            padding: 40px;
            max-width: 500px;
        }

        .error-icon {
            font-size: 80px;
            color: #e74c3c;
            margin-bottom: 30px;
            animation: pulse 2s infinite;
        }

        .error-title {
            font-size: 28px;
            color: #fff;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .error-message {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .error-details {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 30px;
            font-family: 'Consolas', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .error-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .error-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .error-btn.primary {
            background: var(--primary);
            color: white;
        }

        .error-btn.primary:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
        }

        .error-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .error-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        /* Modern styling overrides */
        .dashboard-container {
            background: var(--bg-gradient);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }
        
        .title-bar {
            background-color: var(--title-bar-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            height: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px 0 15px;
        }
        
        .title-bar-text {
            display: flex;
            align-items: center;
            font-size: 14px;
            font-weight: 500;
        }
        
        .title-bar-text i {
            background: var(--primary);
            -webkit-background-clip: text;
            background-clip: text;
            color: var(--primary);
            font-size: 18px;
            margin-right: 8px;
        }
        
        .app-title {
            font-weight: 600;
            color: #ffffff;
            letter-spacing: 0.3px;
        }
        
        .title-divider {
            height: 14px;
            width: 1px;
            background-color: rgba(255, 255, 255, 0.2);
            margin: 0 8px 0 8px;
        }
        
        .sidebar {
            background-color: var(--sidebar-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .avatar {
            background: var(--primary);
            border-radius: 8px;
            width: 40px;
            height: 40px;
        }
        
        .username {
            font-weight: 500;
            font-size: 17px;
            letter-spacing: 0.2px;
        }
        
        .user-plan {
            opacity: 0.8;
            font-size: 13px;
            letter-spacing: 0.1px;
        }
        
        /* Navigation items */
        .nav-item {
            border-radius: 8px;
            margin: 2px 10px;
            padding: 10px 12px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.06);
        }
        
        .nav-item.active {
            background: rgba(0, 102, 255, 0.15);
            border-left: none;
            padding-left: 12px;
        }
        
        .nav-item.inactive {
            opacity: 0.6;
            cursor: not-allowed;
            position: relative;
        }
        
        .nav-item.inactive:hover {
            background-color: rgba(255, 255, 255, 0.06);
        }
        
        .nav-item.inactive:hover span {
            opacity: 0;
            visibility: hidden;
        }
        
        .nav-item.inactive:hover::after {
            content: "Coming soon...";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text);
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }
        
        .nav-item i {
            font-size: 16px;
        }
        
        /* Content styling */
        .content-area {
            padding: 25px;
        }
        
        .page-content h2 {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 15px;
            letter-spacing: 0.3px;
        }
        
        .page-content p {
            color: var(--text-secondary);
            font-size: 15px;
            line-height: 1.5;
        }
        
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .page-header h2 {
            margin-bottom: 0;
        }

        #games-summary {
            font-size: 14px;
            color: var(--primary);
            font-weight: 600;
            background-color: rgba(0, 102, 255, 0.15);
            padding: 6px 14px;
            border-radius: 6px;
            border: 1px solid rgba(0, 102, 255, 0.2);
            display: inline-flex;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        #games-summary i {
            margin-right: 8px;
            font-size: 13px;
        }

        #games-summary.no-games {
            color: var(--text-secondary);
            background-color: rgba(128, 128, 128, 0.1);
            border-color: rgba(128, 128, 128, 0.2);
        }

        #dlcs-summary {
            font-size: 14px;
            color: var(--primary);
            font-weight: 600;
            background-color: rgba(0, 102, 255, 0.15);
            padding: 6px 14px;
            border-radius: 6px;
            border: 1px solid rgba(0, 102, 255, 0.2);
            display: inline-flex;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        #dlcs-summary i {
            margin-right: 8px;
            font-size: 13px;
        }

        #dlcs-summary.no-dlcs {
            color: var(--text-secondary);
            background-color: rgba(128, 128, 128, 0.1);
            border-color: rgba(128, 128, 128, 0.2);
        }
        
        /* Settings page */
        .settings-section {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 25px;
        }
        
        .settings-section h3 {
            font-size: 17px;
            font-weight: 500;
            letter-spacing: 0.2px;
            padding: 15px 20px;
            margin: 0;
            border-bottom: 1px solid var(--border);
        }
        
        .setting-item {
            padding: 15px 20px;
        }
        
        .setting-name {
            font-size: 15px;
            font-weight: 500;
        }
        
        .setting-description {
            font-size: 13px;
            opacity: 0.7;
        }
        
        /* Toggle switch */
        .toggle-switch label {
            background-color: rgba(50, 50, 55, 0.8);
        }
        
        .toggle-switch input:checked + label {
            background: var(--primary);
        }
        
        /* Status indicator */
        .status-indicator {
            background: var(--card-bg);
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 8px 15px;
        }
        
        .status.enabled {
            color: var(--success);
        }
        
        /* File list containers */
        .files-container {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-top: 8px;
            margin-bottom: 10px;
            background: rgba(30, 30, 30, 0.5);
            display: none; /* Hidden by default */
        }
        
        .toggle-btn {
            background: rgba(0, 102, 255, 0.2);
            border: 1px solid rgba(0, 102, 255, 0.3);
            color: var(--primary);
            border-radius: 4px;
            padding: 3px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
        }
        
        .toggle-btn:hover {
            background: rgba(0, 102, 255, 0.3);
        }
        
        .file-item {
            padding: 3px 10px;
            border-bottom: 1px solid var(--border);
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-item:last-child {
            border-bottom: none;
        }
        
        /* File status indicators */
        .file-status.valid {
            color: var(--success);
            font-size: 11px;
        }
        
        .file-status.invalid {
            color: var(--danger);
            font-size: 11px;
        }
        
        /* Buttons */
        .danger-btn {
            background-color: rgba(231, 76, 60, 0.15);
            color: var(--danger);
            border-radius: 6px;
            border: 1px solid rgba(231, 76, 60, 0.3);
            padding: 8px 14px;
            font-weight: 500;
        }
        
        .danger-btn:hover {
            background-color: rgba(231, 76, 60, 0.25);
        }
        
        .logout-btn {
            background-color: rgba(231, 76, 60, 0.15);
            color: var(--danger);
            border-radius: 6px;
            border: 1px solid rgba(231, 76, 60, 0.3);
            padding: 12px;
            font-weight: 500;
            font-size: 14px;
            letter-spacing: 0.3px;
        }
        
        .logout-btn:hover {
            background-color: rgba(231, 76, 60, 0.25);
        }

        /* Account section styles */
        .account-card {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            border-radius: 8px;
            margin: 0 auto;
            position: relative;
            padding-bottom: 35px;
        }
        
        .avatar {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: var(--primary);
            flex-shrink: 0;
            background: rgba(0, 102, 255, 0.1);
            border-radius: 8px;
        }
        
        .account-info-container {
            flex: 1;
            text-align: left;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
        }
        
        .account-name-row {
            display: flex;
            flex-direction: row;
            align-items: center;
        }
        
        .username {
            font-size: 16px;
            font-weight: 600;
            color: white;
        }
        
        /* Plan tag has been removed */
        
        .account-expiry {
            font-size: 12px;
            color: var(--text-secondary);
            margin-left: 0;
            display: block;
        }

        .account-expiry i {
            margin-right: 4px;
            font-size: 11px;
        }

        .device-id-corner {
            position: absolute !important;
            bottom: 8px;
            left: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            z-index: 1;
            pointer-events: none;
        }

        .device-id-corner i.fa-laptop {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
        }

        .device-id-value {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Consolas', 'Monaco', monospace;
            letter-spacing: 0.3px;
        }

        .logout-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            flex-shrink: 0;
            font-size: 15px;
            padding: 0;
            margin-left: 15px;
        }

        .logout-btn i {
            margin-right: 0;
        }
        
        /* Animations */
        .page-content {
            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.15s ease-in, transform 0.15s ease-in;
        }
        
        .page-content.active {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Additional styles to ensure clickability */
        .nav-item, .window-control, .toggle-switch, .danger-btn, .logout-btn {
            cursor: pointer !important;
            z-index: 10 !important;
            position: relative !important;
        }
        
        /* Smooth page transitions */
        .page-content {
            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.15s ease-in, transform 0.15s ease-in;
        }
        
        .page-content.active {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Hover effects */
        .nav-item {
            transition: background-color 0.2s ease, border-left 0.2s ease;
        }
        
        /* Toggle animation */
        .toggle-switch label:before {
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        /* Button animations */
        .danger-btn, .logout-btn {
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        
        .danger-btn:hover, .logout-btn:hover {
            transform: translateY(-2px);
        }
        
        .danger-btn:active, .logout-btn:active {
            transform: translateY(1px);
        }
        
        /* Window controls animation */
        .window-control {
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.1s ease;
        }
        
        .window-control:active {
            transform: scale(0.9);
        }
        
        /* Legacy empty state - removed for new design */
        
        /* User profile styling */
        .user-profile {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .avatar {
            width: 40px;
            height: 40px;
            background: var(--primary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            flex-shrink: 0;
        }
        
        .user-info {
            overflow: hidden;
        }
        
        .username {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .user-plan {
            font-size: 12px;
            color: var(--primary);
            display: block;
            margin-top: 2px;
        }
        
        /* Search and pagination styles */
        .games-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
            gap: 10px;
        }
        
        .search-container {
            display: flex;
            flex: 1;
            align-items: center;
            margin-right: 0;
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0 12px;
            transition: border-color 0.2s ease;
        }

        .search-container:focus-within {
            border-color: var(--primary);
        }
        
        .search-container i {
            color: var(--text-secondary);
            font-size: 14px;
            margin-right: 10px;
        }

        .search-input {
            flex: 1;
            background: transparent;
            border: none;
            padding: 0;
            color: var(--text);
            font-size: 14px;
            height: 38px;
            outline: none;
        }
        
        .search-input::placeholder {
            color: var(--text-secondary);
        }

        .search-btn, .search-btn:hover {
            display: none;
        }
        
        /* Add Game Button */
        .add-game-btn {
            height: 40px;
            width: 40px;
            border-radius: 6px;
            background: rgba(30, 30, 30, 0.7);
            color: var(--text-secondary);
            border: 1px solid var(--border);
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
            flex-shrink: 0;
        }
        
        .add-game-btn:hover {
            background: rgba(45, 45, 45, 0.8);
            color: var(--text);
            border-color: rgba(255, 255, 255, 0.15);
        }
        
        .add-game-btn:active {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }

        .add-game-btn i {
            margin-right: 0;
        }
        
        .pagination-container {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-top: 25px;
            gap: 8px;
        }
        
        .pagination-btn {
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 6px;
            height: 32px;
            width: 32px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: rgba(45, 45, 45, 0.8);
            color: var(--text);
            border-color: rgba(255, 255, 255, 0.15);
        }
        
        .pagination-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .page-info {
            margin: 0;
            display: flex;
            align-items: center;
            background-color: rgba(30, 30, 30, 0.7);
            border: 1px solid var(--border);
            border-radius: 6px;
            height: 32px;
            padding: 0 8px;
        }

        .page-input {
            width: 30px;
            background: transparent;
            border: none;
            color: var(--text);
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            outline: none;
            padding: 0;
            margin: 0;
        }

        /* Remove number input spinners for a cleaner look */
        .page-input::-webkit-outer-spin-button,
        .page-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .page-input[type=number] {
            -moz-appearance: textfield;
        }
        
        #total-pages-display {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            margin-left: 4px;
        }

        .games-loading-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
            padding: 6px 12px;
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .games-loading-indicator i {
            color: var(--primary);
            font-size: 12px;
        }

        #games-loading-progress {
            font-weight: 500;
            color: var(--text);
        }

        /* Game toggle switch */
        .game-toggle {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            flex-shrink: 0;
        }
        
        .game-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .game-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(50, 50, 55, 0.8);
            transition: .3s;
            border-radius: 20px;
        }
        
        .game-toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        
        .game-toggle input:checked + .game-toggle-slider {
            background-color: var(--primary);
        }
        
        .game-toggle input:checked + .game-toggle-slider:before {
            transform: translateX(20px);
        }
        
        /* Game cards */
        .game-card {
            display: flex;
            background: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid var(--border);
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
            align-items: center;
            position: relative;
            justify-content: space-between;
        }
        
        .game-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            background: var(--card-hover);
            border-color: rgba(255, 255, 255, 0.15);
        }
        
        /* Redesigned game cards */
        .game-card.redesigned {
            display: grid;
            grid-template-columns: 180px 1fr auto;
            padding: 0;
            overflow: hidden;
            gap: 0;
        }
        
        .game-img-col {
            position: relative;
            width: 180px;
            height: 100px;
            overflow: hidden;
        }
        
        .game-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .game-img-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 100%);
        }
        
        .game-img-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        
        .disabled-game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            z-index: 6;
            pointer-events: none;
        }
        
        .disabled-game-text {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .game-info-col {
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            min-height: 100px;
            text-align: left;
        }
        
        .game-card-header {
            margin-bottom: 8px;
            width: 100%;
        }
        
        .game-title-row {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            width: 100%;
            margin-bottom: 5px;
            text-align: left;
        }
        
        .game-name {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 280px;
            line-height: 1.2;
            text-align: left;
        }
        
        .game-id {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .game-meta-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
            max-width: 100%;
        }
        
        .meta-tag {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 4px;
            height: 22px;
            color: #aaaaaa;
        }
        
        .meta-tag i {
            margin-right: 6px;
            font-size: 11px;
            opacity: 0.9;
        }
        
        .meta-tag.genre {
            background-color: rgba(0, 102, 255, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(0, 102, 255, 0.2);
        }
        
        .meta-tag.developer {
            background-color: rgba(30, 30, 35, 0.6);
            color: #aaaaaa;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .meta-tag.date {
            background-color: rgba(30, 30, 35, 0.6);
            color: #aaaaaa;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .meta-tag.action {
            background-color: rgba(0, 102, 255, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(0, 102, 255, 0.2);
        }
        
        .meta-tag.casual {
            background-color: rgba(46, 204, 113, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(46, 204, 113, 0.2);
        }
        
        .meta-tag.rpg {
            background-color: rgba(155, 89, 182, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(155, 89, 182, 0.2);
        }
        
        .meta-tag.adventure {
            background-color: rgba(241, 196, 15, 0.15);
            color: #aaaaaa;
            border: 1px solid rgba(241, 196, 15, 0.2);
        }
        
        .meta-tag.loading {
            font-style: italic;
            opacity: 0.7;
        }
        
        .game-controls-corner {
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding: 10px;
            gap: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            align-items: center;
        }
        
        .update-btn {
            background: rgba(30, 30, 35, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .update-btn:hover {
            background: rgba(0, 102, 255, 0.2);
            color: var(--primary);
            border-color: rgba(0, 102, 255, 0.3);
        }
        
        /* Small toggle switch */
        .toggle-switch-small {
            position: relative;
            display: inline-block;
            width: 30px;
            height: 16px;
            margin-left: 8px;
        }
        
        .toggle-switch-small input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider-small {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(50, 50, 55, 0.8);
            transition: .3s;
            border-radius: 20px;
        }
        
        .toggle-slider-small:before {
            position: absolute;
            content: "";
            height: 10px;
            width: 10px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        
        .toggle-switch-small input:checked + .toggle-slider-small {
            background-color: var(--primary);
        }
        
        .toggle-switch-small input:checked + .toggle-slider-small:before {
            transform: translateX(14px);
        }
        
        /* Toggle item in action menu */
        .action-item.toggle-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .game-content {
            display: flex;
            align-items: center;
            flex: 1;
        }
        
        .game-info {
            flex: 1;
            margin-left: 15px;
        }
        
        .game-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .game-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .game-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--primary), var(--primary-hover));
            border-radius: 8px;
            margin-right: 15px;
            color: white;
            font-size: 20px;
            flex-shrink: 0;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            overflow: hidden;
        }
        
        .game-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .game-card:hover .game-icon {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .game-title {
            margin: 0 0 5px 0;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.2px;
            transition: color 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 250px;
        }
        
        .game-card:hover .game-title {
            color: var(--primary);
        }
        
        .game-meta {
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .game-meta span {
            display: inline-flex;
            align-items: center;
        }
        
        .game-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 5px;
        }
        
        .game-detail {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .game-detail i {
            color: var(--primary);
            font-size: 11px;
            width: 14px;
            text-align: center;
        }
        
        .game-detail.error {
            color: var(--danger);
            grid-column: span 2;
        }
        
        /* Loading state */
        .game-card.loading .game-icon {
            background: rgba(30, 30, 30, 0.7);
            animation: pulse 1.5s infinite;
        }
        
        .game-card.loading .game-title {
            color: var(--text-secondary);
            opacity: 0.7;
        }
        
        /* Error state */
        .game-card.error .game-icon {
            background: rgba(231, 76, 60, 0.2);
            color: var(--danger);
        }
        
        .game-status {
            padding: 3px 8px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s ease;
            align-self: flex-start;
            margin-top: 2px;
        }
        
        .game-status.enabled {
            background: rgba(46, 204, 113, 0.2);
            color: var(--success);
            border: 1px solid rgba(46, 204, 113, 0.3);
        }
        
        .game-status.enabled:before {
            content: '';
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: var(--success);
        }
        
        .game-status.disabled {
            background: rgba(231, 76, 60, 0.2);
            color: var(--danger);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .game-status.disabled:before {
            content: '';
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: var(--danger);
        }
        
        .loading-indicator {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
        }
        
        /* Popup Styles - Enhanced */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }
        
        .popup-content {
            background: linear-gradient(180deg, rgba(15, 15, 15, 0.9) 0%, rgba(12, 12, 12, 0.9) 100%);
            border-radius: 12px;
            width: 90%;
            max-width: 420px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.08);
            overflow: hidden;
            animation: popupFadeIn 0.2s ease-in-out;
        }
        
        @keyframes popupFadeIn {
            from { opacity: 0; transform: scale(0.98) translateY(10px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            background-color: rgba(10, 10, 12, 0.5);
        }
        
        .popup-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 500;
            color: #fff;
        }
        
        .popup-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        
        .popup-close:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text);
        }
        
        .popup-body {
            padding: 25px;
        }
        
        .popup-footer {
            padding: 15px 25px;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            background-color: rgba(10, 10, 12, 0.3);
        }
        
        /* Confirmation message styling */
        .confirmation-message {
            display: flex;
            align-items: flex-start;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(243, 156, 18, 0.1);
            border: 1px solid rgba(243, 156, 18, 0.2);
        }
        
        .confirmation-message i {
            flex-shrink: 0;
            margin-top: 3px;
        }

        /* Form Styles */
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: var(--text);
            font-size: 14px;
        }
        
        .form-input {
            width: 100%;
            padding: 10px;
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 14px;
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .form-hint {
            display: block;
            margin-top: 15px;
            padding: 12px;
            background-color: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.5;
        }

        .form-hint a {
            color: var(--primary);
            text-decoration: none;
            font-weight: 500;
        }

        .form-hint a:hover {
            text-decoration: underline;
        }
        
        #add-game-popup .form-group {
            margin-bottom: 0;
        }
        
        /* Replace the form-group.dlc-toggle style with checkbox style */
        .form-group.dlc-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(30, 30, 30, 0.4);
            padding: 10px 15px;
            border-radius: 6px;
            margin-top: 15px;
        }

        .form-group.dlc-toggle label {
            margin-bottom: 0;
            color: var(--text-secondary);
        }

        .form-group.dlc-toggle .toggle-switch {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Add new dlc-checkbox style for the footer */
        .dlc-checkbox {
            display: flex;
            align-items: center;
            background: transparent;
            padding: 0;
            border-radius: 6px;
            height: auto;
            border: none;
            cursor: pointer;
            opacity: 1;
            transition: all 0.2s ease;
            flex-grow: 1;
        }
        
        .dlc-checkbox:hover {
            opacity: 0.8;
        }
        
        .dlc-checkbox input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: rgba(40, 40, 45, 1);
            border: 2px solid rgba(100, 100, 110, 1);
            border-radius: 4px;
            margin-right: 10px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .dlc-checkbox input[type="checkbox"]:hover {
            border-color: var(--primary);
            background: rgba(50, 50, 55, 1);
            transform: scale(1.02);
        }
        
        .dlc-checkbox input[type="checkbox"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.3);
        }
        
        .dlc-checkbox label {
            color: rgba(255, 255, 255, 0.75);
            font-size: 14px;
            cursor: pointer;
            user-select: none;
            font-weight: 500;
            transition: color 0.2s ease;
        }
        
        .dlc-checkbox label:hover {
            color: var(--primary);
        }

        /* Input checked styles */
        .dlc-checkbox input[type="checkbox"]:checked {
            background: var(--primary);
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.2);
            transform: scale(1.05);
        }
        
        .dlc-checkbox input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .dlc-checkbox input[type="checkbox"]:checked + label {
            color: var(--primary);
            font-weight: 600;
        }
        
        #add-game-popup .primary-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--primary);
            color: white;
            border: none;
            font-weight: 500;
            padding: 0 20px;
            border-radius: 6px;
            transition: all 0.2s ease;
            height: 40px;
        }

        #add-game-popup .primary-btn:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 102, 255, 0.2);
        }
        
        #add-game-popup .primary-btn:active {
            transform: translateY(0);
            box-shadow: none;
        }
        
        .secondary-btn {
            background: rgba(160, 160, 160, 0.1);
            color: var(--text);
            border: 1px solid rgba(160, 160, 160, 0.3);
            border-radius: 6px;
            padding: 8px 14px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .secondary-btn:hover {
            background: rgba(160, 160, 160, 0.2);
        }
        
        /* Game Action Menu */
        .game-actions {
            position: relative;
            margin-left: 10px;
            z-index: 30;
        }
        
        .action-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            width: 30px;
            height: 30px;
            border-radius: 4px;
        }
        
        .action-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text);
        }
        
        /* Action menu styling - enhanced */
        .action-menu {
            position: absolute;
            right: 0;
            top: 35px;
            background: linear-gradient(180deg, rgba(15, 15, 15, 0.9) 0%, rgba(12, 12, 12, 0.9) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            width: 200px;
            overflow: hidden;
            display: none;
            pointer-events: none;
            padding: 6px 0;
        }
        
        .action-menu.show {
            display: block;
            pointer-events: auto;
            z-index: 1000;
            animation: fadeIn 0.15s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .action-item {
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #eee;
            font-size: 13.5px;
            transition: background-color 0.1s ease;
        }
        
        .action-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .action-item.danger:hover {
            background: rgba(231, 76, 60, 0.15);
        }
        
        .action-item i {
            margin-right: 0;
            width: 16px;
            text-align: center;
            font-size: 14px;
        }
        
        .action-item.danger {
            color: #ff4d4d;
        }
        
        .action-item.danger i {
            color: #ff4d4d;
        }
        
        /* ID display as divider with left/right alignment */
        .game-id-display {
            padding: 10px 15px;
            margin-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            color: #777;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: default;
        }
        
        .game-id-display:hover {
            background: none;
        }
        
        .game-id-label {
            color: #777;
            font-weight: normal;
        }
        
        .game-id-value {
            color: #aaa;
            font-family: monospace;
        }
        
        /* Global Action Menu */
        #global-action-menu {
            position: fixed;
            z-index: 1500; /* Ensure this is higher than any other element */
        }
        
        .action-item {
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            color: #eee;
            font-size: 14px;
            position: relative;
        }
        
        .action-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .action-item i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
            font-size: 15px;
        }
        
        .action-item.danger {
            color: #ff4d4d;
        }
        
        .action-item.danger i {
            color: #ff4d4d;
        }
        
        /* Ensure toggle doesn't appear in dropdown */
        .action-menu .game-toggle {
            display: none;
        }

        /* Patch Notes Styling - Improved Modern Version */
        .patch-notes {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            margin-top: 15px;
            overflow: hidden;
            max-height: 500px;
            display: flex;
            flex-direction: column;
        }

        .patch-notes-header {
            background: rgba(20, 20, 20, 0.6);
            padding: 14px 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .patch-notes-title {
            font-size: 15px;
            font-weight: 600;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .patch-notes-title i {
            color: var(--primary);
            font-size: 18px;
        }

        .patch-notes-version {
            font-size: 13px;
            color: var(--primary);
            background: rgba(0, 102, 255, 0.12);
            padding: 4px 10px;
            border-radius: 20px;
            font-weight: 500;
        }

        .patch-notes-content {
            padding: 0;
            overflow-y: auto;
            flex-grow: 1;
        }

        .patch-notes-section {
            margin-bottom: 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        }

        .patch-notes-section:last-child {
            border-bottom: none;
        }

        .patch-notes-section-header {
            padding: 12px 18px;
            background: rgba(15, 15, 15, 0.5);
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .patch-notes-section-header:hover {
            background: rgba(25, 25, 25, 0.7);
        }

        .patch-notes-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .patch-notes-section-title i {
            font-size: 14px;
            width: 16px;
            text-align: center;
        }

        .patch-notes-list-container {
            padding: 12px 18px;
            background: rgba(10, 10, 10, 0.2);
        }

        .patch-notes-list {
            list-style: none;
            padding-left: 24px;
            margin: 0;
        }

        .patch-notes-item {
            position: relative;
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 8px;
            padding-left: 5px;
        }

        .patch-notes-item:last-child {
            margin-bottom: 0;
        }

        .patch-notes-item::before {
            content: "";
            position: absolute;
            left: -16px;
            top: 8px;
            width: 6px;
            height: 6px;
            background-color: var(--primary);
            border-radius: 50%;
        }

        .patch-date {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 10px 18px;
            text-align: right;
            border-top: 1px solid rgba(255, 255, 255, 0.04);
            background: rgba(15, 15, 15, 0.4);
        }

        /* Patch types - Use icons and colors instead of borders */
        .patch-notes-section.highlights .patch-notes-section-title i { color: #FFC107; }
        .patch-notes-section.features .patch-notes-section-title i { color: #4CAF50; }
        .patch-notes-section.improvements .patch-notes-section-title i { color: #2196F3; }
        .patch-notes-section.fixes .patch-notes-section-title i { color: #FF9800; }
        .patch-notes-section.security .patch-notes-section-title i { color: #F44336; }
        .patch-notes-section.removed .patch-notes-section-title i { color: #9E9E9E; }

        /* Highlight items based on importance */
        .patch-notes-item.highlight {
            color: #fff;
            font-weight: 500;
        }

        .patch-notes-comment {
            padding: 12px 18px;
            border-top: 1px solid rgba(255, 255, 255, 0.04);
            background: rgba(15, 15, 15, 0.3);
        }

        .comment-content {
            background: rgba(20, 20, 20, 0.4);
            border-radius: 8px;
            padding: 12px;
            font-style: italic;
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.5;
        }

        /* Collapsible sections */
        .section-toggle {
            margin-left: auto;
            font-size: 12px;
            transition: transform 0.2s ease;
        }

        .collapsed .section-toggle {
            transform: rotate(-90deg);
        }

        .patch-notes-section.collapsed .patch-notes-list-container {
            display: none;
        }

        /* Type indicators - cleaner design */
        .patch-notes-header .type-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 8px;
            letter-spacing: 0.5px;
        }

        .type-indicator.patch {
            background-color: rgba(33, 150, 243, 0.15);
            color: #42a5f5;
        }

        .type-indicator.notification {
            background-color: rgba(156, 39, 176, 0.15);
            color: #ab47bc;
        }

        .type-indicator.alert {
            background-color: rgba(244, 67, 54, 0.15);
            color: #ef5350;
        }

        .type-indicator.warning {
            background-color: rgba(255, 152, 0, 0.15);
            color: #ffa726;
        }

        .type-indicator.info {
            background-color: rgba(76, 175, 80, 0.15);
            color: #66bb6a;
        }

        .type-indicator.maintenance {
            background-color: rgba(255, 152, 0, 0.15);
            color: #ffa726;
        }

        /* Message style for non-patch notes */
        .patch-notes-message {
            padding: 18px;
            line-height: 1.6;
            font-size: 14px;
            color: var(--text);
            background: rgba(10, 10, 10, 0.2);
        }

        /* Remove the colored left borders and use a cleaner approach */
        .patch-notes.type-patch,
        .patch-notes.type-notification,
        .patch-notes.type-alert,
        .patch-notes.type-info,
        .patch-notes.type-maintenance,
        .patch-notes.type-warning {
            border-left: none;
        }

        /* Internal Comments Section */
        .internal-comments-section {
            margin-top: 10px;
            border-top: 1px dashed rgba(255, 0, 0, 0.3);
            padding: 12px 18px;
            background: rgba(20, 0, 0, 0.2);
            display: none; /* Hidden by default, will be shown for admin users */
        }

        .internal-comments-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 13px;
            font-weight: 600;
            color: #ff5252;
        }

        .internal-comments-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .internal-comment-item {
            padding: 6px 0;
            color: #ff8a80;
            font-size: 13px;
            border-bottom: 1px dotted rgba(255, 0, 0, 0.2);
            line-height: 1.5;
        }

        .internal-comment-item:last-child {
            border-bottom: none;
        }

        /* Slow loading message styling */
        .loading-slow-message {
            margin-top: 15px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .loading-exit-link {
            color: var(--primary);
            margin-top: 8px;
            display: block;
            cursor: pointer;
            text-decoration: underline;
            transition: color 0.2s ease;
        }

        .loading-exit-link:hover {
            color: var(--text);
        }

        /* ... existing code ...

        /* Update notification and progress styling */
        .update-list {
            padding: 20px 25px;
            display: flex;
            flex-direction: column;
        }

        .update-title {
            font-weight: 500;
            color: var(--text);
            margin-bottom: 20px;
            font-size: 15px;
            line-height: 1.4;
        }
        
        .version-container {
            background: rgba(20, 20, 20, 0.4);
            border: 1px solid rgba(70, 70, 70, 0.5);
            border-radius: 6px;
            padding: 12px 15px;
            margin-bottom: 20px;
        }
        
        .version-info {
            display: flex;
            flex-direction: column;
        }
        
        .version-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            color: var(--text);
            font-size: 14px;
        }
        
        .version-item:last-child {
            margin-bottom: 0;
        }
        
        .version-item i {
            margin-right: 8px;
            font-size: 16px;
        }
        
        .version-item.outdated {
            color: #eeeeee;
        }
        
        .version-item.outdated i {
            color: #ff5252;
        }
        
        .version-item.outdated span {
            color: #ff5252;
            text-decoration: line-through;
            margin-left: 5px;
        }
        
        .version-item.new {
            margin-top: 8px;
        }
        
        .version-item.new i {
            color: #4CAF50;
        }
        
        .version-item.new span {
            color: var(--primary);
            font-weight: 600;
            font-size: 15px;
            margin-left: 5px;
        }

        .update-description {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        /* Footer buttons styling */
        .popup-footer {
            padding: 15px 25px;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            background-color: rgba(10, 10, 12, 0.3);
        }
        
        #add-game-popup .primary-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--primary);
            color: white;
            border: none;
            font-weight: 500;
            padding: 10px 20px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        #add-game-popup .primary-btn:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 102, 255, 0.2);
        }
        
        .footer-btn {
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 5px;
        }
        
        .footer-btn.secondary-btn {
            background: rgba(40, 40, 40, 0.8);
            color: var(--text);
            border: none;
            padding: 0 20px;
            min-width: 80px;
        }
        
        .footer-btn.primary-btn {
            background: #0d6efd;
            color: white;
            border: none;
            padding: 0 20px;
            min-width: 140px;
        }
        
        .footer-btn i {
            margin-right: 5px;
        }

        /* Restart button in title bar */
        .window-control.restart {
            background: rgba(30, 30, 30, 0.7);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            transition: color 0.2s, background-color 0.2s;
            border-radius: 4px;
            padding: 0 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-right: 8px;
            height: 28px;
            min-width: fit-content;
            white-space: nowrap;
            border: 1px solid rgba(80, 80, 80, 0.3);
        }
        
        .window-control.restart:hover {
            color: var(--primary);
            background-color: rgba(40, 40, 40, 0.9);
        }
        
        .window-control.restart i {
            font-size: 12px;
        }
        
        .window-control.restart span {
            white-space: nowrap;
            overflow: visible;
        }

        .window-control.restart.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Tooltip for disabled restart button */
        .restart-tooltip {
            position: fixed;
            background: rgb(20, 20, 20);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 2147483647;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            transform: translate(-50%, 10px);
        }

        .restart-tooltip.show {
            display: block;
            animation: fadeIn 0.2s ease;
        }

        .window-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            height: 100%;
            min-width: fit-content;
            position: relative;
        }

        /* Game developer info under title */
        .game-developer.loading {
            color: #666;
            font-style: italic;
        }

        /* Last update date styling */
        .last-update-date {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Consolas', 'Courier New', monospace;
            background-color: rgba(15, 15, 15, 0.7);
            padding: 3px 8px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 5;
        }
        
        .last-update-date.matching {
            color: #2ecc71; /* Green for matching dates */
            border-color: rgba(46, 204, 113, 0.3);
        }
        
        .last-update-date.outdated {
            color: #e74c3c; /* Red for different dates */
            border-color: rgba(231, 76, 60, 0.3);
        }
        
        /* DLC Page Specific Styles - Clean Implementation */
        .dlc-cards-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-top: 20px;
            padding: 0;
            max-width: 100%;
            overflow: hidden;
        }

        /* DLC Card */
        .dlc-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            transition: border-color 0.2s ease;
            width: 100%;
            box-sizing: border-box;
        }

        .dlc-card:hover {
            border-color: var(--text-secondary);
        }

        /* DLC Card Header - Rebuilt from scratch */
        .dlc-card-header {
            display: flex;
            align-items: center;
            padding: 12px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border-bottom: 1px solid transparent;
            min-height: 60px;
        }

        .dlc-card-header:hover {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .dlc-card.expanded .dlc-card-header {
            border-bottom-color: var(--border);
        }

        /* Game Info - Simple flex layout */
        .game-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            min-width: 0;
            overflow: hidden;
            max-width: calc(100% - 150px);
        }

        /* Game Thumbnail */
        .game-thumbnail {
            width: 115px;
            height: 43px;
            border-radius: 4px;
            object-fit: cover;
            border: 1px solid var(--border);
            flex-shrink: 0;
        }

        /* Game Details */
        .game-details {
            flex: 1;
            min-width: 0;
            max-width: 400px;
            display: flex;
            align-items: center;
            height: 43px; /* Match thumbnail height */
            overflow: hidden;
        }

        /* Game Name */
        .dlc-card .game-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            transform: translateY(-3px);
            max-width: 350px;
            width: 100%;
        }

        /* Card Controls */
        .card-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
            margin-left: 15px;
        }

        .dlc-count {
            font-size: 11px;
            color: var(--text-secondary);
            background: rgba(255, 255, 255, 0.05);
            padding: 4px 8px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 500;
            white-space: nowrap;
        }

        .expand-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 6px;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .expand-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text);
        }

        .dlc-card.expanded .expand-toggle i {
            transform: rotate(180deg);
        }

        /* DLC List */
        .dlc-list {
            background: rgba(10, 10, 10, 0.3);
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .dlc-card.expanded .dlc-list {
            max-height: 2000px;
            opacity: 1;
        }

        /* DLC List Header */
        .dlc-list-header {
            display: grid;
            grid-template-columns: 70px 1fr 80px;
            gap: 16px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border);
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-sizing: border-box;
        }

        .dlc-col-id {
            text-align: left;
        }

        .dlc-col-name {
            text-align: left;
        }

        .dlc-col-actions {
            text-align: center;
        }
        
        /* Loading State Styling */
        .dlc-loading-info {
            padding: 20px;
            text-align: center;
        }
        
        .loading-message {
            margin-bottom: 20px;
        }
        
        .loading-message i {
            color: var(--primary);
            font-size: 18px;
            margin-right: 10px;
        }
        
        .loading-message p {
            color: var(--text);
            font-size: 16px;
            margin: 10px 0;
        }
        
        .loading-progress {
            margin-bottom: 15px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-hover));
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .progress-info {
            display: flex;
            justify-content: space-between;
            color: var(--text-secondary);
            font-size: 13px;
        }
        
        .loading-details {
            display: flex;
            justify-content: space-between;
            color: var(--text-secondary);
            font-size: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 10px;
        }

        /* DLC Items */
        .dlc-item {
            display: grid;
            grid-template-columns: 70px 1fr 80px;
            gap: 16px;
            align-items: center;
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: background-color 0.2s ease;
            position: relative;
            box-sizing: border-box;
        }

        .dlc-item:hover {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .dlc-item:last-child {
            border-bottom: none;
        }

        /* DLC Content */
        .dlc-id {
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 600;
            text-align: left;
        }

        .dlc-name {
            font-size: 13px;
            color: var(--text);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 500;
            text-align: left;
            max-width: 100%;
            width: 100%;
            display: block;
        }

        /* Action Button */
        .dlc-action-btn {
            background: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
        }

        .dlc-action-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Menus */
        .dlc-item-menu {
            position: fixed;
            background: linear-gradient(180deg, rgba(15, 15, 15, 0.95) 0%, rgba(12, 12, 12, 0.95) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            z-index: 9999;
            min-width: 140px;
            overflow: hidden;
            display: none;
            pointer-events: none;
            padding: 4px 0;
        }

        .dlc-item-menu.show {
            display: block;
            pointer-events: auto;
            animation: fadeIn 0.15s ease-in-out;
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(-20px); }
        }

        .dlc-item-menu .action-item {
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #eee;
            font-size: 13.5px;
            transition: background-color 0.1s ease;
        }

        .dlc-item-menu .action-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .dlc-item-menu .action-item.danger {
            color: var(--danger);
        }

        .dlc-item-menu .action-item.danger:hover {
            background: rgba(231, 76, 60, 0.1);
        }

        .dlc-item-menu .action-item i {
            color: #bbb;
            font-size: 12px;
            margin-left: 8px;
        }

        .dlc-item-menu .action-item.danger i {
            color: #ff4d4d;
        }

        /* DLC Action Menu - using games page style */
        .action-menu {
                          position: absolute;
              right: 0;
              top: -50px;
            background: linear-gradient(180deg, rgba(15, 15, 15, 0.9) 0%, rgba(12, 12, 12, 0.9) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            width: 200px;
            overflow: hidden;
            display: none;
            pointer-events: none;
            padding: 6px 0;
        }

        /* Specific style for DLC action menus */
        [id^="dlc-action-menu-"], [id^="dlc-item-menu-"] {
            right: auto;
            left: auto;
            transform: translateX(30%);
            margin-right: 0;
        }
        
        .action-menu.show {
            display: block;
            pointer-events: auto;
            z-index: 1000;
            animation: fadeIn 0.15s ease-in-out;
        }

        .action-menu .action-item {
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #eee;
            font-size: 13.5px;
            transition: background-color 0.1s ease;
        }

        .action-menu .action-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .action-menu .action-item.danger {
            color: var(--danger);
        }

        .action-menu .action-item.danger:hover {
            background: rgba(231, 76, 60, 0.1);
        }

        .action-menu .action-item i {
            color: #bbb;
            font-size: 12px;
            margin-left: 8px;
        }

        .action-menu .action-item.danger i {
            color: #ff4d4d;
        }
        /* DLC Remove Button - Square button with bin icon */
        .dlc-item > *:last-child {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .dlc-remove-btn {
            background: none;
            border: 1px solid rgba(231, 76, 60, 0.3);
            color: var(--danger);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0;
            border-radius: 4px;
            position: relative;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1;
        }

        .dlc-remove-btn:hover {
            background-color: rgba(231, 76, 60, 0.1);
            border-color: rgba(231, 76, 60, 0.5);
            color: #e74c3c;
            transform: scale(1.05);
        }

        .dlc-remove-btn:active {
            transform: scale(0.95);
        }

        .dlc-remove-btn i {
            font-size: 14px;
            pointer-events: none;
        }

        .dlc-remove-btn:focus {
            outline: 2px solid var(--danger);
            outline-offset: 2px;
        }

        /* Premium Popup Styles */
        #premium-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        #premium-popup-overlay.show {
            display: flex;
        }

        .premium-popup-content {
            background: linear-gradient(180deg, rgba(15, 15, 15, 0.95) 0%, rgba(12, 12, 12, 0.95) 100%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 28px;
            max-width: 380px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            position: relative;
            animation: popupFadeIn 0.2s ease-in-out;
        }

        @keyframes popupFadeIn {
            from { opacity: 0; transform: scale(0.98) translateY(10px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .premium-popup-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }

        .premium-icon {
            font-size: 36px;
            color: #FFD700;
            display: block;
            margin-bottom: 10px;
        }

        .premium-popup-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 6px;
        }

        .premium-popup-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .premium-features {
            list-style: none;
            padding: 0;
            margin: 18px 0;
        }

        .premium-feature {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            color: var(--text);
            font-size: 13px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .premium-feature:last-child {
            margin-bottom: 0;
        }

        .premium-feature i {
            color: var(--primary);
            font-size: 14px;
            margin-right: 12px;
            min-width: 14px;
        }

        .premium-popup-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .premium-btn {
            width: 100%;
            padding: 11px 20px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            outline: none;
        }

        .premium-btn-primary {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #111;
            border: 1px solid rgba(255, 215, 0, 0.3);
            font-weight: 600;
            text-shadow: 0px 1px 0px rgba(255, 255, 255, 0.2);
        }

        .premium-btn-primary:hover {
            background: linear-gradient(135deg, #FFE44D, #FFB347);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        }

        .premium-btn-primary:active {
            transform: translateY(0);
        }

        .premium-btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .premium-btn-secondary:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: rgba(255, 255, 255, 0.12);
        }

        /* Game Warning Popup Styles */
        #game-warning-popup-overlay.show {
            display: flex;
        }

        .game-warning-popup-content {
            background: linear-gradient(180deg, rgba(15, 15, 15, 0.95) 0%, rgba(12, 12, 12, 0.95) 100%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 28px;
            max-width: 420px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            position: relative;
            animation: popupFadeIn 0.2s ease-in-out;
        }

        .game-warning-popup-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
            position: relative;
        }

        .help-btn {
            position: absolute;
            top: 0;
            left: 0;
            width: 28px;
            height: 28px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;
        }

        .help-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--primary);
            border-color: var(--primary);
        }

        .warning-icon {
            font-size: 36px;
            color: var(--warning);
            display: block;
            margin-bottom: 10px;
        }

        .game-warning-popup-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 6px;
        }

        .game-warning-popup-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .warning-notices {
            margin: 18px 0;
        }

        .warning-notice-item {
            display: flex;
            align-items: flex-start;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(243, 156, 18, 0.1);
            border: 1px solid rgba(243, 156, 18, 0.3);
            border-radius: 6px;
            color: var(--text);
            font-size: 13px;
        }

        .warning-notice-item:last-child {
            margin-bottom: 0;
        }

        .warning-notice-item i {
            color: var(--warning);
            font-size: 14px;
            margin-right: 10px;
            margin-top: 2px;
            min-width: 14px;
        }

        .warning-notice-content {
            flex: 1;
        }

        .warning-notice-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--warning);
        }

        .warning-notice-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.4;
        }

        .warning-message {
            display: flex;
            align-items: flex-start;
            padding: 12px;
            background: rgba(0, 102, 255, 0.1);
            border: 1px solid rgba(0, 102, 255, 0.3);
            border-radius: 6px;
            color: var(--text);
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 20px;
        }

        .warning-message i {
            color: var(--primary);
            font-size: 14px;
            margin-right: 10px;
            margin-top: 1px;
            min-width: 14px;
        }

        .game-warning-popup-buttons {
            display: flex;
            flex-direction: row;
            gap: 8px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .warning-btn {
            flex: 1;
            padding: 11px 20px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            outline: none;
        }

        .warning-btn-primary {
            background: var(--warning);
            color: #111;
            border: 1px solid rgba(243, 156, 18, 0.3);
            font-weight: 600;
        }

        .warning-btn-primary:hover {
            background: #e67e22;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
        }

        .warning-btn-primary:active {
            transform: translateY(0);
        }

        .warning-btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .warning-btn-secondary:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: rgba(255, 255, 255, 0.12);
        }

        /* Game cards container */
    </style>
    <!-- Fixed size: 800px width  600px height -->
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-logo">
            <i class="fas fa-shield-alt"></i>
        </div>
        <div class="loading-progress-container">
            <div class="loading-progress-bar" id="loading-progress-bar"></div>
        </div>
        <div class="loading-text">Loading SWA V2...</div>
        <div class="loading-slow-message" id="loading-slow-message">
            Application is taking longer than expected to load.
            <span class="loading-exit-link" onclick="exitApplication()">Exit Application</span>
        </div>
    </div>

    <!-- Connection Error Overlay -->
    <div class="connection-error-overlay" id="connection-error-overlay" style="display: none;">
        <div class="error-content">
            <div class="error-icon">
                <i class="fas fa-exclamation-triangle"></i>
            </div>
            <h2 class="error-title">Connection Failed</h2>
            <p class="error-message" id="error-message">Unable to connect to SWA servers. Please check your internet connection.</p>
            <div class="error-details" id="error-details"></div>
            <div class="error-buttons">
                <button class="error-btn primary" onclick="window.chrome.webview.postMessage('open-support')">
                    <i class="fas fa-life-ring"></i> Contact Support
                </button>
                <button class="error-btn secondary" onclick="window.chrome.webview.postMessage('close')">
                    <i class="fas fa-times"></i> Exit Application
                </button>
            </div>
        </div>
    </div>

    <!-- Premium Popup Overlay -->
    <div id="premium-popup-overlay" class="popup-overlay">
        <div class="premium-popup-content">
            <div class="premium-popup-header">
                <div class="premium-icon">
                    <i class="fas fa-crown"></i>
                </div>
                <h2 class="premium-popup-title">Premium Required</h2>
                <p class="premium-popup-subtitle">This game requires a premium account</p>
            </div>

            <ul class="premium-features">
                <li class="premium-feature">
                    <i class="fas fa-check"></i>
                    <span>Access to all premium games</span>
                </li>
                <li class="premium-feature">
                    <i class="fas fa-check"></i>
                    <span>No rate limits</span>
                </li>
                <li class="premium-feature">
                    <i class="fas fa-check"></i>
                    <span>Priority support</span>
                </li>
            </ul>

            <div class="premium-popup-buttons">
                <button class="premium-btn premium-btn-primary" onclick="openPremiumPage()">
                    Get Premium
                </button>
                <button class="premium-btn premium-btn-secondary" onclick="closePremiumPopup()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Custom tooltip for DRM/Launcher badges -->
    <div id="badge-tooltip" class="badge-tooltip">
        <div class="badge-tooltip-title"></div>
        <div class="badge-tooltip-content"></div>
    </div>

    <!-- Game Warning Popup (DRM/Launcher/No Info) -->
    <div id="game-warning-popup-overlay" class="popup-overlay">
        <div class="game-warning-popup-content">
            <div class="game-warning-popup-header">
                <button class="help-btn" onclick="openNoticeFAQ()" title="Learn more about game compatibility">
                    <i class="fas fa-question-circle"></i>
                </button>
                <div class="warning-icon">
                    <i class="fas fa-exclamation-triangle"></i>
                </div>
                <h2 class="game-warning-popup-title" id="warning-popup-title">Compatibility Notice</h2>
                <p class="game-warning-popup-subtitle" id="warning-popup-subtitle">This game may have compatibility issues</p>
            </div>

            <div class="warning-notices" id="warning-notices">
                <!-- Dynamically populated warnings -->
            </div>

            <div class="warning-message" id="warning-message">
                <i class="fas fa-info-circle"></i>
                <span>We cannot guarantee this game will work correctly.</span>
            </div>

            <div class="game-warning-popup-buttons">
                <button class="warning-btn warning-btn-secondary" onclick="closeGameWarningPopup()">
                    Cancel
                </button>
                <button class="warning-btn warning-btn-primary" id="warning-add-anyway-btn" onclick="confirmAddGame()">
                    Add Anyway
                </button>
            </div>
        </div>
    </div>

    <script>
        // Loading screen will only hide when completeLoading() is called after data is loaded
        // No auto-hide timeout - waiting for real data to be ready
        console.log('Loading screen initialized - waiting for data...');
    </script>

    <div class="dashboard-container">
        <!-- Title Bar -->
        <div class="title-bar">
            <div class="title-bar-text">
                <i class="fas fa-shield-alt"></i>
                <span class="app-title">SWA V2</span>
                <div class="title-divider"></div>
                <span class="log-message" id="log-message"></span>
            </div>
            <div class="window-controls">
                <button class="window-control restart" id="restart-steam-btn" onclick="restartSteamAndApp()">
                    <i class="fas fa-sync-alt"></i>
                    <span>Restart Steam</span>
                </button>
                <button class="window-control minimize" onclick="minimizeWindow()">
                    <i class="fas fa-minus"></i>
                </button>
                <button class="window-control close" onclick="closeWindow()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="dashboard-content">
            <!-- Sidebar -->
            <div class="sidebar">
                <!-- User Profile -->
                <div class="user-profile">
                    <div class="avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="user-info">
                        <h3 class="username">Loading...</h3>
                        <span class="user-plan">Loading...</span>
                    </div>
                </div>

                <!-- Navigation -->
                <nav class="main-nav">
                    <ul>
                        <li class="nav-item active" data-page="home" onclick="navigateTo('home')">
                            <i class="fas fa-home"></i>
                            <span>Home</span>
                        </li>
                        <li class="nav-item" data-page="games" onclick="navigateTo('games')">
                            <i class="fas fa-gamepad"></i>
                            <span>Games</span>
                        </li>
                        <li class="nav-item" data-page="dlcs"  onclick="navigateTo('dlcs')">
                            <i class="fas fa-puzzle-piece"></i>
                            <span>DLCs</span>
                        </li>
                        <li class="nav-item inactive" data-page="launcher">
                            <i class="fas fa-rocket"></i>
                            <span>Launcher</span>
                        </li>
                        <li class="nav-item inactive" data-page="online">
                            <i class="fas fa-globe"></i>
                            <span>Online</span>
                        </li>
                    </ul>
                </nav>

                <!-- Rotating Banner -->
                <div class="ad-banner-container" id="ad-banner-container" style="display: none;">
                    <div class="rotating-banner" id="rotating-banner">
                        <!-- Banner slides will be dynamically generated from API -->
                    </div>
                </div>

                <!-- Settings (at bottom) -->
                <div class="bottom-nav">
                    <div class="nav-item" data-page="settings" onclick="navigateTo('settings')">
                        <i class="fas fa-cog"></i>
                        <span>Settings</span>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="content-area">
                <!-- Home Page (default) -->
                <div class="page-content active" id="home-page">
                    <h2>SWA V2 Updates</h2>
                    <p>Latest changes and improvements to the application.</p>
                    
                    <div class="patch-notes" id="patch-notes-container">
                        <!-- Patch notes will be populated here -->
                    </div>
                </div>

                <!-- Games Page -->
                <div class="page-content" id="games-page">
                    <div class="page-header">
                        <h2>Games Library</h2>
                        <span id="games-summary"></span>
                    </div>
                    
                    <div class="games-header">
                        <!-- Search Bar -->
                        <div class="search-container">
                            <i class="fas fa-search"></i>
                            <input type="text" id="game-search" placeholder="Search games..." class="search-input">
                        </div>
                        
                        <!-- Scan for Games Button -->
                        <button class="add-game-btn" onclick="scanGames()">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        
                        <!-- Add Game Button -->
                        <button class="add-game-btn" onclick="showAddGamePopup()">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    
                    <div class="games-list">
                        <!-- Game entries will be dynamically populated -->
                        <div class="empty-state" id="games-empty-state">
                            <div class="empty-state-container">
                                <i class="fas fa-gamepad"></i>
                                <p>No games found</p>
                            </div>
                        </div>
                        <div id="games-container" style="display: none;"></div>
                    </div>
                    
                    <!-- Pagination Controls -->
                    <div class="pagination-container" id="pagination-controls" style="display: none;">
                        <button class="pagination-btn" id="prev-page-btn" onclick="changePage(-1)">
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <div class="page-info">
                            <input type="text" id="page-input" class="page-input" value="1" onkeydown="handlePageJump(event)">
                            <span id="total-pages-display">/ 1</span>
                        </div>
                        <button class="pagination-btn" id="next-page-btn" onclick="changePage(1)">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                        <div class="games-loading-indicator" id="games-loading-indicator" style="display: none;">
                            <i class="fas fa-sync fa-spin"></i>
                            <span id="games-loading-text">Loading game info</span>
                            <span id="games-loading-progress"></span>
                        </div>
                    </div>
                </div>

                <!-- DLCs Page -->
                <div class="page-content" id="dlcs-page">
                    <div class="page-header">
                        <h2>DLC Manager</h2>
                        <span id="dlcs-summary"></span>
                    </div>
                    
                    <div class="games-header">
                        <!-- Search Bar -->
                        <div class="search-container">
                            <i class="fas fa-search"></i>
                            <input type="text" id="dlc-search" placeholder="Search DLCs..." class="search-input" oninput="searchDLCs()">
                        </div>

                        <!-- Refresh DLCs Button -->
                        <button class="add-game-btn" onclick="refreshDLCs()" title="Refresh DLCs">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        
                    </div>

                    <!-- DLC Cards Container -->
                    <div class="dlc-cards-container" id="dlc-cards-container">
                        <!-- DLC cards will be dynamically populated here -->
                        <div class="dlc-cards-container">
                            <i class="fas fa-puzzle-piece"></i>
                            <p>No DLC data found. Click "Load DLCs" to scan your Steam installation.</p>
                        </div>
                    </div>
                </div>

                <!-- Launcher Page -->
                <div class="page-content" id="launcher-page">
                    <h2>Game Launcher</h2>
                    <p>Launch your games directly from SWA.</p>
                    <div class="empty-state">
                        <i class="fas fa-rocket"></i>
                        <p>Coming soon...</p>
                    </div>
                </div>

                <!-- Online Page -->
                <div class="page-content" id="online-page">
                    <h2>Online Features</h2>
                    <p>Access online features and connectivity options.</p>
                    <div class="empty-state">
                        <i class="fas fa-globe"></i>
                        <p>Coming soon...</p>
                    </div>
                </div>

                <!-- Settings Page -->
                <div class="page-content" id="settings-page">
                    <h2>Settings</h2>
                    
                    <div class="settings-section">
                        <h3>SWA Functions</h3>
                        <div class="setting-item">
                            <div class="setting-info">
                                <span class="setting-name">Enable SWA</span>
                                <span class="setting-description">Enable SWA functionality for your games</span>
                            </div>
                            <div class="toggle-switch">
                                <input type="checkbox" id="enable-swa" checked onclick="toggleSwa(this.checked)">
                                <label for="enable-swa"></label>
                            </div>
                        </div>
                        

                        <div class="setting-item">
                            <div class="setting-info">
                                <span class="setting-name">Current Version</span>
                                <span class="setting-description" id="current-version">Git E1.2</span>
                            </div>
                            <button class="primary-btn" id="check-updates-btn">
                                <i class="fas fa-sync-alt"></i>
                                <span>Check for Updates</span>
                            </button>
                        </div>
                        
                        <div class="setting-item">
                            <div class="setting-info">
                                <span class="setting-name">Remove All Games</span>
                                <span class="setting-description">Delete all games from your library</span>
                            </div>
                            <button class="danger-btn" onclick="removeAllGames()">Remove</button>
                        </div>
                        
                        <div class="setting-item">
                            <div class="setting-info">
                                <span class="setting-name">Remove All DLCs</span>
                                <span class="setting-description">Delete all DLCs from your library</span>
                            </div>
                            <button class="danger-btn" onclick="removeAllDLCs()">Remove</button>
                        </div>
                    </div>

                    <div class="settings-section">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding-bottom: 10px; border-bottom: 1px solid var(--border); margin-bottom: 15px;">
                            <h3 style="margin: 0; padding: 0; border: none;">Steam Configuration</h3>
                            <span class="warning-badge" id="warning-badge" onmouseenter="showWarningTooltip(event)" onmouseleave="hideWarningTooltip()" onmousemove="updateWarningTooltipPosition(event)">
                                <i class="fas fa-exclamation-triangle"></i>
                                <span>Warning</span>
                            </span>
                        </div>

                        <!-- Preferred Executable -->
                        <div class="setting-item">
                            <div class="setting-info">
                                <span class="setting-name">Preferred Executable</span>
                                <span class="setting-description">Choose which executable to use for launching games</span>
                            </div>
                            <div class="custom-select" id="executable-select-container">
                                <div class="custom-select-trigger" onclick="toggleExecutableDropdown()">
                                    <span id="selected-executable-text">SWAv2</span>
                                    <i class="fas fa-chevron-down"></i>
                                </div>
                                <div class="custom-select-options" id="executable-options">
                                    <div class="custom-select-option" data-value="swav2.exe" onclick="selectExecutable('swav2.exe', 'SWAv2')">
                                        <i class="fas fa-rocket"></i>
                                        <div class="option-content">
                                            <div class="option-name-row">
                                                <span class="option-name">SWAv2</span>
                                                <span class="option-badge">Recommended</span>
                                            </div>
                                            <span class="option-desc">SWA Custom Steam launcher</span>
                                        </div>
                                    </div>
                                    <div class="custom-select-option" data-value="steam.exe" onclick="selectExecutable('steam.exe', 'Steam')">
                                        <i class="fab fa-steam"></i>
                                        <div class="option-content">
                                            <span class="option-name">Steam</span>
                                            <span class="option-desc">Standard Steam launcher</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Custom Steam Path -->
                        <div class="setting-item">
                            <div class="setting-info">
                                <span class="setting-name">Custom Steam Path</span>
                                <span class="setting-description">Select custom Steam installation directory</span>
                            </div>
                            <button class="primary-btn" onclick="openSteamPathPopup()">
                                <i class="fas fa-cog"></i>
                                <span>Configure</span>
                            </button>
                        </div>

                        <!-- Steam Path and Plugin Status Side by Side -->
                        <div style="display: flex; align-items: center; gap: 30px; margin: 15px 0 0 0; padding: 15px; background: rgba(255, 255, 255, 0.02); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 6px; font-size: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0;">
                                <span style="font-size: 11px; color: var(--text-muted); white-space: nowrap;">Steam Path:</span>
                                <span id="selected-steam-path" style="font-size: 12px; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">Not set - using default</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                                <span style="font-size: 11px; color: var(--text-muted); white-space: nowrap;">Plugin Status:</span>
                                <span id="plugin-status" style="font-size: 12px; color: var(--text-secondary); white-space: nowrap;">Detecting...</span>
                                <button class="repair-plugin-btn" id="repair-plugin-btn" onclick="repairPlugin()" title="Repair/Install Plugin" style="display: none;">
                                    <i class="fas fa-wrench"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h3>Account</h3>
                        <div class="account-card">
                            <div style="margin-right: 15px;" class="avatar">
                                <i class="fas fa-user-circle"></i>
                            </div>
                            <div class="account-info-container">
                                <div class="account-name-row">
                                    <span class="username">Loading...</span>
                                </div>
                                <span class="account-expiry" id="account-expiry">Loading...</span>
                            </div>
                            <button class="logout-btn" onclick="logout()">
                                <i class="fas fa-sign-out-alt"></i>
                            </button>
                            <div class="device-id-corner">
                                <i class="fas fa-laptop"></i>
                                <span class="device-id-value" id="device-id-value">Loading...</span>
                            </div>
                        </div>
                    </div>

                    <!-- Debug Section -->
                    <div class="settings-section" id="debug-section" style="display: none;">
                        <h3>Debug Information</h3>
                        <div class="debug-info">
                            <div class="info-item">
                                <span class="info-label">Steam Path:</span>
                                <span class="info-value" id="steam-path">Detecting...</span>
                            </div>
                            <div class="info-item">
                                <button class="primary-btn" onclick="refreshSteamPath()">
                                    <i class="fas fa-sync-alt"></i>
                                    <span>Refresh Steam Path</span>
                                </button>
                            </div>
                            <div class="info-item">
                                <button class="primary-btn" onclick="openDevTools()">
                                    <i class="fas fa-code"></i>
                                    <span>Open DevTools</span>
                                </button>
                            </div>
                            <div class="info-item">
                                <span class="info-label">All .lua Files Found:</span>
                                <button class="toggle-btn" onclick="toggleFilesList('all-st-files-container')">
                                    <i class="fas fa-chevron-down"></i> Show/Hide
                                </button>
                                <div class="files-container" id="all-st-files-container">
                                    <div class="info-value" id="all-st-files">None</div>
                                </div>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Valid Game Files:</span>
                                <button class="toggle-btn" onclick="toggleFilesList('valid-game-files-container')">
                                    <i class="fas fa-chevron-down"></i> Show/Hide
                                </button>
                                <div class="files-container" id="valid-game-files-container">
                                    <div class="info-value" id="valid-game-files">None</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Error Console Section -->
                    <div class="debug-section-console" id="error-console-section" style="display: none;">
                        <div class="info-header">
                            <span class="info-label">Error Log Console</span>
                                </div>
                        <div class="console-container">
                            <pre id="error-console" class="error-console">Loading error log...</pre>
                            </div>
                        <div class="console-controls">
                            <button class="primary-btn" onclick="refreshErrorLog()">
                                <i class="fas fa-sync-alt"></i>
                                <span>Refresh</span>
                                </button>
                            <button class="secondary-btn" onclick="clearErrorConsole()">
                                <i class="fas fa-trash"></i>
                                <span>Clear</span>
                            </button>
                            <div class="toggle-container">
                                <input type="checkbox" id="auto-refresh" class="toggle-input" checked>
                                <label for="auto-refresh">Auto-refresh</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Status Indicator (Bottom Right) -->
        <div class="status-indicator">
            <span class="status enabled">
                <i class="fas fa-circle"></i>
                SWA Enabled
            </span>
        </div>
    </div>

    <!-- Add Game Popup -->
    <div id="add-game-popup" class="popup-overlay">
        <div class="popup-content">
            <div class="popup-header">
                <h3>Add New Game</h3>
                <button class="popup-close" onclick="hideAddGamePopup()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="popup-body">
                <div class="form-group">
                    <label for="new-game-id">Game ID:</label>
                    <input type="text" id="new-game-id" placeholder="Enter game ID or steam URL" class="form-input">
                    <div class="form-hint">You can find the game ID on the game's Steam store
                        page URL or use <a href="https://apiurl/gamelist" target="_blank">SWA Cloud</a> to find it.</div>
                </div>
            </div>
            <div class="popup-footer">
                <div class="dlc-checkbox">
                    <input type="checkbox" id="add-dlcs">
                    <label for="add-dlcs">Unlock DLCs</label>
                </div>
                <button class="add-game-btn" onclick="addNewGame()">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
        </div>
    </div>
    <!-- Confirmation Popup -->
    <div id="confirmation-popup" class="popup-overlay">
        <div class="popup-content">
            <div class="popup-header">
                <h3 id="confirmation-title">Confirm Action</h3>
                <button class="popup-close" onclick="hideConfirmationPopup()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="popup-body">
                <div class="confirmation-message">
                    <i class="fas fa-exclamation-triangle" style="color: #f39c12; font-size: 24px; margin-right: 10px;"></i>
                    <span id="confirmation-message">Are you sure you want to proceed?</span>
                </div>
            </div>
            <div class="popup-footer">
                <button class="secondary-btn" onclick="hideConfirmationPopup()">Cancel</button>
                <button class="danger-btn" id="confirm-button" onclick="confirmAction()">
                    <i class="fas fa-trash-alt"></i> Remove
                </button>
            </div>
        </div>
    </div>

    <!-- Add Update Notification Popup -->
    <div id="update-notification" class="popup-overlay">
        <div class="popup-content">
            <div class="popup-header">
                <h3>Update Available</h3>
                <button class="popup-close" onclick="hideUpdateNotification()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="popup-body">
                <div class="update-list">
                    <p class="update-title">A new version of SWA V2 is available.</p>
                    <div class="version-container">
                        <div class="version-info">
                            <div class="version-item outdated">
                                <i class="fas fa-exclamation-circle"></i> Current Version: 
                                <span id="current-version-popup">Git E1.2</span>
                            </div>
                            <div class="version-item new">
                                <i class="fas fa-check-circle"></i> New Version: 
                                <span id="new-version-popup">Git E1.3</span>
                            </div>
                        </div>
                    </div>
                    <p class="update-description">Update to get the latest features and bug fixes.</p>
                </div>
            </div>
            <div class="popup-footer" style="padding: 15px 0; border-top: 1px solid rgba(255, 255, 255, 0.1); text-align: center; display: flex; align-items: center; justify-content: center;">
                <button class="primary-btn" onclick="downloadUpdate()" style="height: 42px; display: inline-flex; align-items: center; background: #0d6efd; color: white; border: none; border-radius: 6px; padding: 0 30px; min-width: 200px; cursor: pointer; font-weight: 500; box-shadow: 0 4px 12px rgba(13, 110, 253, 0.3); transition: all 0.2s ease;">
                    <i class="fas fa-download" style="margin-right: 10px; font-size: 16px;"></i> Update Now
                </button>
            </div>
        </div>
    </div>

    <!-- Add Update Progress Popup -->
    <div id="update-progress" class="popup-overlay">
        <div class="popup-content">
            <div class="popup-header">
                <h3>Downloading Update</h3>
            </div>
            <div class="popup-body">
                <div class="update-progress-container">
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="update-progress-bar"></div>
                    </div>
                    <div class="progress-text" id="update-progress-text">0%</div>
                    <p class="progress-description">Please wait while the update is being downloaded...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Modal for Game Images -->
    <div id="image-modal" class="image-modal">
        <div class="image-modal-content">
            <div class="image-modal-header">
                <h3 class="image-modal-title">Game Image</h3>
                <button class="image-modal-close" onclick="closeImageModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="image-modal-body">
                <div class="image-modal-loading">Loading image...</div>
                <img id="modal-image" style="display: none;" alt="Game screenshot" />
                <div class="image-modal-error" style="display: none;">Failed to load image</div>
            </div>
        </div>
    </div>

    <!-- Custom Tooltip for Warning Badge -->
    <div id="warning-tooltip" class="custom-tooltip">
        <div class="custom-tooltip-header">
            <i class="fas fa-exclamation-triangle"></i>
            <span class="custom-tooltip-title">Experimental Feature</span>
        </div>
        <div class="custom-tooltip-content">
            <p><strong>This feature allows advanced configuration of Steam settings.</strong></p>
            <p> <strong>Warning:</strong> Only modify these settings if you understand how they work!</p>
            <p>Incorrect configuration may prevent Steam or games from launching properly.</p>
            <p style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255, 152, 0, 0.15); color: var(--text-muted); font-size: 12px;">
                <i class="fas fa-info-circle" style="color: var(--primary);"></i>
                Default settings work for most users - only change if you have a specific reason.
            </p>
        </div>
    </div>

    <!-- Restart Button Tooltip -->
    <div class="restart-tooltip" id="restart-tooltip">Enable SWA and install plugin in Settings first</div>

    <!-- Steam Path Configuration Popup -->
    <div id="steam-path-popup" class="popup-overlay">
        <div class="popup-content" style="max-width: 500px;">
            <div class="popup-header">
                <h3>Configure Steam Path</h3>
                <button class="popup-close" onclick="closeSteamPathPopup()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="popup-body">
                <div class="form-group">
                    <label>Steam Installation Path</label>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <input type="text" id="steam-path-input" class="form-input" placeholder="Enter Steam directory path..." style="flex: 1;">
                        <button class="primary-btn" onclick="browseSteamPath()" style="margin: 0; white-space: nowrap;">
                            <i class="fas fa-folder-open"></i>
                            <span>Browse</span>
                        </button>
                    </div>
                    <div class="form-hint">
                        <i class="fas fa-info-circle" style="color: var(--primary); margin-right: 6px;"></i>
                        You can either type the Steam path manually or click Browse to select it. The path should contain steam.exe.
                    </div>
                </div>

                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border);">
                    <button class="primary-btn" onclick="openSteamConfigFile()" style="width: 100%; justify-content: center; margin: 0;">
                        <i class="fas fa-file-code"></i>
                        <span>Open Configuration File</span>
                    </button>
                    <div class="form-hint" style="margin-top: 12px;">
                        Advanced: Directly edit the steam_settings.json configuration file.
                    </div>
                </div>
            </div>
            <div class="popup-footer">
                <button class="secondary-btn" onclick="closeSteamPathPopup()">Cancel</button>
                <button class="primary-btn" onclick="saveSteamPathFromPopup()" style="margin: 0;">
                    <i class="fas fa-save"></i>
                    <span>Save Path</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // User account information
        let userAccountInfo = {
            username: "User",
            status: "Loading...",
            unique_id: "",
            user_id: "",
            expiration_date: "Never",
            device_id: "",
            hwid: ""
        };

        // Keep track of the currently open menu
        let currentOpenMenuId = null;

        // Function to update the UI with user account information
        function updateUserInterface() {
            // Update username
            const usernameElements = document.querySelectorAll('.username');
            usernameElements.forEach(element => {
                element.textContent = userAccountInfo.username;
            });

            // Update plan with expiration date and conditional formatting
            const userPlanElements = document.querySelectorAll('.user-plan');
            const userPlan = userAccountInfo.status.toLowerCase();
            const isStandardPlan = userPlan.includes('standard') || userPlan.includes('standart');
            
            userPlanElements.forEach(element => {
                // For Standard users, just show the plan name without expiration info
                if (isStandardPlan) {
                    element.textContent = userAccountInfo.status;
                    element.style.color = ''; // Reset color
                    return; // Skip the rest of the processing
                }
                
                // Format expiration date based on value
                if (userAccountInfo.expiration_date === "0" || userAccountInfo.expiration_date === 0 ||
                    userAccountInfo.expiration_date === "Never") {
                    // Lifetime subscription
                    element.textContent = 'Lifetime';
                    element.style.color = '#2ecc71'; // Green
                } else if (userAccountInfo.expiration_date === "Loading...") {
                    // Still loading
                    element.textContent = 'Loading...';
                    element.style.color = ''; // Reset color
                } else {
                    // Try to parse the expiration date
                    try {
                        let expiryDate;
                        if (typeof userAccountInfo.expiration_date === 'string') {
                            // Try different date formats
                            if (userAccountInfo.expiration_date.includes('/')) {
                                // MM/DD/YYYY format
                                const parts = userAccountInfo.expiration_date.split('/');
                                expiryDate = new Date(parts[2], parts[0]-1, parts[1]);
                            } else if (userAccountInfo.expiration_date.includes('-')) {
                                // YYYY-MM-DD format
                                expiryDate = new Date(userAccountInfo.expiration_date);
                            } else {
                                // Try as timestamp
                                expiryDate = new Date(parseInt(userAccountInfo.expiration_date));
                            }
                        } else if (typeof userAccountInfo.expiration_date === 'number') {
                            // Treat as timestamp
                            expiryDate = new Date(userAccountInfo.expiration_date);
                        }
                        
                        // If we have a valid date, calculate days remaining
                        if (expiryDate && !isNaN(expiryDate.getTime())) {
                            const today = new Date();
                            const diffTime = expiryDate - today;
                            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                            
                            // Format with conditional text color
                            if (diffDays < 0) {
                                // Expired
                                element.textContent = `Expired`;
                                element.style.color = '#e74c3c'; // Red
                            } else if (diffDays < 3) {
                                // Less than 3 days - Red
                                element.textContent = `${diffDays}d left`;
                                element.style.color = '#e74c3c'; // Red
                            } else if (diffDays < 15) {
                                // Less than 15 days - Yellow
                                element.textContent = `${diffDays}d left`;
                                element.style.color = '#f39c12'; // Yellow
                            } else {
                                // More than 15 days - Green
                                element.textContent = `${diffDays}d left`;
                                element.style.color = '#2ecc71'; // Green
                            }
                        } else {
                            // Fallback when date parsing fails
                            element.textContent = userAccountInfo.status;
                            element.style.color = ''; // Reset color
                        }
                    } catch (error) {
                        console.error("Error parsing expiration date:", error);
                        // Fallback to status if date parsing fails
                        element.textContent = userAccountInfo.status;
                        element.style.color = ''; // Reset color
                    }
                }
            });

            // Update device ID display
            const deviceIdValue = document.getElementById('device-id-value');
            if (deviceIdValue) {
                // Try multiple possible field names from the API
                const hwid = userAccountInfo.hwid || userAccountInfo.device_id || userAccountInfo.deviceId;

                if (hwid && hwid !== '' && hwid !== 'Loading...') {
                    deviceIdValue.textContent = hwid;
                    console.log('Device ID updated:', hwid);
                } else {
                    // Request device ID from C# if not available
                    if (typeof window.chrome !== 'undefined' && window.chrome.webview) {
                        window.chrome.webview.postMessage('get-device-id');
                    }
                    deviceIdValue.textContent = 'Loading...';
                }
            }

            // Update plan badge
            updatePlanBadge();
        }

        // Function to process server response
        function processServerResponse(response) {
            try {
                // Parse the response if it's a string
                const data = typeof response === 'string' ? JSON.parse(response) : response;

                // Update user account info
                userAccountInfo.username = data.username || userAccountInfo.username;
                userAccountInfo.status = data.status || userAccountInfo.status;
                userAccountInfo.unique_id = data.unique_id || userAccountInfo.unique_id;
                userAccountInfo.user_id = data.user_id || userAccountInfo.user_id;
                userAccountInfo.device_id = data.device_id || data.hwid || userAccountInfo.device_id;
                userAccountInfo.hwid = data.hwid || data.device_id || userAccountInfo.hwid;

                // Handle status_expires timestamp
                if (data.status_expires) {
                    userAccountInfo.status_expires = data.status_expires;
                    userAccountInfo.expiration_date = data.status_expires;
                } else if (data.premium_expires_in_days === null) {
                    userAccountInfo.expiration_date = "Lifetime";
                    userAccountInfo.status_expires = null;
                } else if (data.premium_expires_in_days !== undefined) {
                    // Convert days to actual expiration date
                    const expiryDate = new Date();
                    expiryDate.setDate(expiryDate.getDate() + parseInt(data.premium_expires_in_days));
                    userAccountInfo.expiration_date = expiryDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                    userAccountInfo.status_expires = null;
                } else if (data.expiration_date) {
                    userAccountInfo.expiration_date = data.expiration_date;
                    userAccountInfo.status_expires = null;
                }

                // Update the UI with the new information
                updateUserInterface();

                console.log("User account information updated:", userAccountInfo);

                // Complete the loading process after ensuring UI is fully rendered
                // Use requestAnimationFrame to wait for next paint cycle
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        completeLoading();
                    }, 300);
                });
            } catch (error) {
                console.error("Error processing server response:", error);
                
                // Complete loading even on error
                completeLoading();
            }
        }

        // Function to update patch notes with data from backend
        function updatePatchNotes(patchNotesData) {
            console.log('Received patch notes data:', patchNotesData);
            
            if (!patchNotesData) {
                console.error('No patch notes data received');
                return;
            }
            
            try {
                // Process the data - handle various formats
                if (Array.isArray(patchNotesData)) {
                    // When API returns an array, render each note
                    renderMultiplePatchNotes(patchNotesData);
                } 
                // If it returns a single object
                else if (typeof patchNotesData === 'object') {
                    renderPatchNotes(patchNotesData);
                }
                else {
                    console.warn('Unexpected patch notes format');
                    // Show error in the container
                    const container = document.getElementById('patch-notes-container');
                    if (container) {
                        container.innerHTML = `
                            <div class="patch-notes-header">
                                <div class="patch-notes-title">
                                    <i class="fas fa-exclamation-circle"></i>
                                    <span>Error loading patch notes</span>
                                </div>
                            </div>
                            <div class="patch-notes-message">
                                Received unexpected data format from the server.
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Error processing patch notes:', error);
                // Show error in the container
                const container = document.getElementById('patch-notes-container');
                if (container) {
                    container.innerHTML = `
                        <div class="patch-notes-header">
                            <div class="patch-notes-title">
                                <i class="fas fa-exclamation-circle"></i>
                                <span>Error</span>
                            </div>
                        </div>
                        <div class="patch-notes-message">
                            An error occurred while processing patch notes data.
                        </div>
                    `;
                }
            }
        }

        // Message handler for WebView communication
        if (window.chrome && window.chrome.webview) {
            window.chrome.webview.addEventListener('message', function(event) {
                const message = event.data;

                // Handle debug mode status
                if (typeof message === 'string') {
                    try {
                        const parsed = JSON.parse(message);
                        if (parsed.type === 'debug-mode') {
                            console.log('Received debug mode status:', parsed.enabled);
                            handleDebugMode(parsed.enabled);
                            return;
                        }
                    } catch (e) {
                        // Not JSON, continue with other handlers
                    }
                }

                // Check if the message contains user account info
                if (message && typeof message === 'string' && message.includes('Server response:')) {
                    const jsonStart = message.indexOf('{');
                    if (jsonStart !== -1) {
                        const jsonData = message.substring(jsonStart);
                        processServerResponse(jsonData);
                    }
                }
                // Handle patch notes data
                else if (message && typeof message === 'string' && message.includes('Patch notes response:')) {
                    try {
                        const jsonStart = message.indexOf('[') !== -1 ? message.indexOf('[') : message.indexOf('{');
                        if (jsonStart !== -1) {
                            const jsonData = message.substring(jsonStart);
                            const patchNotesData = JSON.parse(jsonData);
                            updatePatchNotes(patchNotesData);
                        }
                    } catch (error) {
                        console.error('Error parsing patch notes data:', error);
                    }
                }
                // Handle game info processed confirmation
                else if (message && typeof message === 'string' && message.includes('gameInfoProcessed:')) {
                    try {
                        const gameId = message.split(':')[1];
                        console.log(`Confirmed game info processed successfully for ${gameId}`);
                    } catch (error) {
                        console.error('Error handling game info processed confirmation:', error);
                    }
                }
                // Handle game list data
                else if (message && typeof message === 'string' && (message.includes('Game IDs:') || message.includes('games JSON'))) {
                    try {
                        console.log("Received game data message:", message);
                        // Look for JSON array
                        const gameIdsStart = message.indexOf('[');
                        if (gameIdsStart !== -1) {
                            const gameIdsJson = message.substring(gameIdsStart);
                            const gameData = JSON.parse(gameIdsJson);
                            console.log("Parsed game data:", gameData);
                            updateGamesList(gameData);
                        } else if (message.includes('Game IDs: []') || message.includes('No games found')) {
                            // Handle empty game list
                            console.log("Empty game list detected");
                            updateGamesList([]);
                        }
                    } catch (error) {
                        console.error('Error parsing game IDs:', error);
                        // If parsing fails, set empty list
                        updateGamesList([]);
                    }
                }
                // Handle regular account data object
                else if (message && typeof message === 'object' && message.username) {
                    processServerResponse(message);
                }
                // Handle patch notes data as object
                else if (message && typeof message === 'object' && (Array.isArray(message) || message.type || message.version)) {
                    updatePatchNotes(message);
                }
            });

            // Request debug mode status after listener is set up
            window.chrome.webview.postMessage('get-debug-mode');
        }

        // Handle debug mode
        function handleDebugMode(enabled) {
            console.log('Debug mode:', enabled);

            const debugSection = document.getElementById('debug-section');
            const errorConsoleSection = document.getElementById('error-console-section');

            if (enabled) {
                // Show debug sections
                if (debugSection) debugSection.style.display = 'block';
                if (errorConsoleSection) errorConsoleSection.style.display = 'block';
            } else {
                // Hide debug sections
                if (debugSection) debugSection.style.display = 'none';
                if (errorConsoleSection) errorConsoleSection.style.display = 'none';
            }
        }

        // Prevent page refresh with keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Block Ctrl+F (find)
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                return false;
            }

            // Prevent Ctrl+R (refresh)
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                return false;
            }

            // Prevent F5 (refresh)
            if (e.key === 'F5') {
                e.preventDefault();
                return false;
            }

            // Prevent other browser shortcuts
            if ((e.ctrlKey || e.metaKey) && (e.key === 'n' || e.key === 't')) {
                e.preventDefault();
                return false;
            }
        });
        
        // Prevent right-click context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });
        
        // Direct function calls for all interactive elements
        function minimizeWindow() {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('minimize');
            }
        }
        
        function closeWindow() {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('close');
            }
        }
        
        function startDrag(e) {
            // Don't do drag if clicking on window controls
            if (e.target.closest('.window-controls')) {
                return;
            }
            
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('drag:start');
            }
        }
        
        function navigateTo(pageId) {
    // Check if the page is inactive
    const navItem = document.querySelector(`.nav-item[data-page="${pageId}"]`);
    if (navItem && navItem.classList.contains('inactive')) {
        return; // Don't navigate to inactive pages
    }
    
    // Check if this page is already active
    const currentActive = document.querySelector(`.nav-item.active`);
    if (currentActive && currentActive.getAttribute('data-page') === pageId) {
        return; // Don't navigate if already on this page
    }
    
    // Update active nav item
    document.querySelectorAll('.nav-item').forEach(navItem => {
        navItem.classList.remove('active');
    });
    document.querySelector(`.nav-item[data-page="${pageId}"]`).classList.add('active');
    
    // First hide all pages with a fade out transition
    document.querySelectorAll('.page-content.active').forEach(page => {
        page.style.opacity = '0';
        page.style.transform = 'translateY(5px)';
    });
    
    // After a short delay, switch the active page and fade it in
    setTimeout(() => {
        document.querySelectorAll('.page-content').forEach(page => {
            page.classList.remove('active');
        });
        const newPage = document.getElementById(`${pageId}-page`);
        newPage.classList.add('active');
        // Force a reflow to ensure the animation happens
        void newPage.offsetWidth;
        newPage.style.opacity = '1';
        newPage.style.transform = 'translateY(0)';
        
        // If navigating to games page, check if we need to show empty state
        if (pageId === 'games' && (!filteredGames || filteredGames.length === 0)) {
            console.log("Navigated to games page with no games");
            // Don't auto-scan, just show the empty state
            showGamesEmptyState();
        }

        // If navigating to settings page, load Steam settings
        if (pageId === 'settings' && window.chrome && window.chrome.webview) {
            window.chrome.webview.postMessage('loadSteamSettings');
        }
    }, 100);
}
        
        function toggleSwa(isEnabled) {
            const statusIndicator = document.querySelector('.status');

            // Add transition effect
            statusIndicator.style.transition = 'opacity 0.2s ease';
            statusIndicator.style.opacity = '0';

            setTimeout(() => {
                if (isEnabled) {
                    statusIndicator.classList.remove('disabled');
                    statusIndicator.classList.add('enabled');
                    statusIndicator.innerHTML = '<i class="fas fa-circle"></i> SWA Enabled';
                } else {
                    statusIndicator.classList.remove('enabled');
                    statusIndicator.classList.add('disabled');
                    statusIndicator.innerHTML = '<i class="fas fa-circle"></i> SWA Disabled';
                }

                // Fade back in
                statusIndicator.style.opacity = '1';

                // Update restart button state
                updateRestartButtonState(isEnabled);

                // Send status to C# app
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage(`swa:${isEnabled ? 'enable' : 'disable'}`);
                }
            }, 200);
        }

        function updateRestartButtonState(isEnabled) {
            const restartBtn = document.getElementById('restart-steam-btn');
            if (restartBtn) {
                if (isEnabled) {
                    restartBtn.classList.remove('disabled');
                    restartBtn.onmouseenter = null;
                    restartBtn.onmouseleave = null;
                    restartBtn.onmousemove = null;
                } else {
                    restartBtn.classList.add('disabled');
                    restartBtn.onmouseenter = showRestartTooltip;
                    restartBtn.onmouseleave = hideRestartTooltip;
                    restartBtn.onmousemove = moveRestartTooltip;
                }
            }
        }

        function showRestartTooltip(e) {
            const tooltip = document.getElementById('restart-tooltip');
            if (tooltip) {
                // Check what's wrong and show appropriate message
                const swaEnabled = document.getElementById('enable-swa')?.checked ?? true;
                const pluginStatus = document.getElementById('plugin-status')?.textContent || '';
                const pluginOk = pluginStatus === 'Detected';

                if (!swaEnabled && !pluginOk) {
                    tooltip.textContent = 'Enable SWA and install plugin in Settings first';
                } else if (!swaEnabled) {
                    tooltip.textContent = 'Enable SWA in Settings first';
                } else if (!pluginOk) {
                    tooltip.textContent = 'Plugin not installed - click repair button in Settings';
                }

                tooltip.classList.add('show');
                moveRestartTooltip(e);
            }
        }

        function moveRestartTooltip(e) {
            const tooltip = document.getElementById('restart-tooltip');
            if (tooltip && tooltip.classList.contains('show')) {
                tooltip.style.left = e.clientX + 'px';
                tooltip.style.top = e.clientY + 'px';
            }
        }

        function hideRestartTooltip() {
            const tooltip = document.getElementById('restart-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
            }
        }

        // Initialize restart button state on page load
        window.addEventListener('DOMContentLoaded', function() {
            // Check initial SWA state from the status indicator
            const statusIndicator = document.querySelector('.status');
            if (statusIndicator) {
                const isEnabled = statusIndicator.classList.contains('enabled');
                updateRestartButtonState(isEnabled);
            }
        });

        function removeAllGames() {
            showConfirmationPopup(
                'Remove All Games', 
                'Are you sure you want to remove all games from your library? This action cannot be undone.', 
                'removeAllGamesConfirmed'
            );
        }
        
        function removeAllGamesConfirmed() {
            // Handle game removal logic
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('removeAllGamesConfirmed');
            }
            
            // Show feedback message
            const gamesSummary = document.getElementById('games-summary');
            if (gamesSummary) {
                gamesSummary.textContent = 'All games have been removed.';
                gamesSummary.style.color = 'var(--danger)';
            }
            
            // Clear the games list
            allGames = [];
            filteredGames = [];
            renderGamesPage();
        }
        
        function removeAllDLCs() {
            showConfirmationPopup(
                'Remove All DLCs', 
                'Are you sure you want to remove all DLCs from your library? This action cannot be undone.', 
                'removeAllDLCsConfirmed'
            );
        }
        
        function removeAllDLCsConfirmed() {
            // Handle DLC removal logic
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('dlcs:removeAll');
            }
        }
        
        function removeGame(gameId) {
            console.log(`removeGame called with gameId: ${gameId}`);
            
            // ,     
            const popup = document.getElementById('confirmation-popup');
            if (!popup) {
                console.error('confirmation-popup element not found!');
                //    ,  removeGameConfirmed 
                removeGameConfirmed(gameId);
                return;
            }
            
            showConfirmationPopup(
                'Remove Game', 
                `Are you sure you want to remove game ${gameId} from your library? This action cannot be undone.`, 
                `removeGameConfirmed:${gameId}`
            );
        }
        
        function removeGameConfirmed(gameId) {
            console.log(`Removing game: ${gameId}`);
            // Close all menus
            document.querySelectorAll('.action-menu.show').forEach(menu => {
                menu.classList.remove('show');
            });
            
            try {
                // Actual implementation will send message to backend
                if (window.chrome && window.chrome.webview) {
                    console.log(`Sending message to backend: game:remove:${gameId}`);
                    window.chrome.webview.postMessage(`game:remove:${gameId}`);
                    
                    //     ,     
                    setTimeout(() => {
                        console.log('Scanning games after removal');
                        if (window.chrome && window.chrome.webview) {
                            window.chrome.webview.postMessage('scanGames');
                        }
                    }, 500);
                } else {
                    console.error('WebView2 not available for communication with backend');
                }
            } catch (error) {
                console.error(`Error in removeGameConfirmed: ${error.message}`);
            }
        }
        
        function removeGameFile(gameId) {
            showConfirmationPopup(
                'Remove Game', 
                `Are you sure you want to remove game ${gameId} from your system? This action cannot be undone.`, 
                `removeGameFileConfirmed:${gameId}`
            );
        }
        
        function removeGameFileConfirmed(gameId) {
            console.log(`Removing file for game: ${gameId}`);
            // Close all menus
            document.querySelectorAll('.action-menu.show').forEach(menu => {
                menu.classList.remove('show');
            });
            
            // Send message to backend to remove the file
            if (window.chrome && window.chrome.webview) {
                console.log(`Sending message to backend: game:remove:file:${gameId}`);
                window.chrome.webview.postMessage(`game:remove:file:${gameId}`);
            }
            
            // Refresh the games list
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('scanGames');
            }
        }
        
        // Confirmation popup functions
        let pendingAction = null;
        
        function showConfirmationPopup(title, message, action) {
            console.log(`showConfirmationPopup called with action: ${action}`);
            
            // Set popup content
            const titleElement = document.getElementById('confirmation-title');
            const messageElement = document.getElementById('confirmation-message');
            
            if (!titleElement) {
                console.error('confirmation-title element not found!');
            } else {
                titleElement.textContent = title;
            }
            
            if (!messageElement) {
                console.error('confirmation-message element not found!');
            } else {
                messageElement.textContent = message;
            }
            
            // Store the pending action
            pendingAction = action;
            
            // Show popup
            const popup = document.getElementById('confirmation-popup');
            if (popup) {
                popup.style.display = 'flex';
                
                // ,  popup  
                setTimeout(() => {
                    if (window.getComputedStyle(popup).display !== 'flex') {
                        console.error('Popup is not displaying! CSS might be overriding display:flex');
                        //    ,   
                        if (action.startsWith('removeGameConfirmed:')) {
                            const gameId = action.split(':')[1];
                            removeGameConfirmed(gameId);
                        }
                    } else {
                        console.log('Popup is displaying correctly');
                    }
                }, 100);
                
                // Add escape key listener
                document.addEventListener('keydown', closeConfirmationOnEscape);
            } else {
                console.error('confirmation-popup element not found in showConfirmationPopup!');
                //    ,   
                if (action.startsWith('removeGameConfirmed:')) {
                    const gameId = action.split(':')[1];
                    removeGameConfirmed(gameId);
                }
            }
        }
        
        function hideConfirmationPopup() {
            const popup = document.getElementById('confirmation-popup');
            if (popup) {
                popup.style.display = 'none';
                pendingAction = null;
                
                // Remove escape key listener
                document.removeEventListener('keydown', closeConfirmationOnEscape);
            }
        }
        
        function closeConfirmationOnEscape(e) {
            if (e.key === 'Escape') {
                hideConfirmationPopup();
            }
        }
        
        function confirmAction() {
            console.log(`confirmAction called with pendingAction: ${pendingAction}`);
            
            //   
            const currentAction = pendingAction;
            
            if (!currentAction) {
                console.error('confirmAction called but pendingAction is empty!');
                return;
            }
            
            // Hide popup first
            hideConfirmationPopup();
            
            try {
                // Execute the pending action
                if (currentAction === 'removeAllGamesConfirmed') {
                    removeAllGamesConfirmed();
                } else if (currentAction === 'removeAllDLCsConfirmed') {
                    removeAllDLCsConfirmed();
                } else if (currentAction.startsWith('removeGameConfirmed:')) {
                    const gameId = currentAction.split(':')[1];
                    console.log(`Calling removeGameConfirmed with gameId: ${gameId}`);
                    removeGameConfirmed(gameId);
                } else if (currentAction.startsWith('removeGameFileConfirmed:')) {
                    const gameId = currentAction.split(':')[1];
                    console.log(`Calling removeGameFileConfirmed with gameId: ${gameId}`);
                    removeGameFileConfirmed(gameId);
                } else {
                    console.error(`Unknown pendingAction: ${currentAction}`);
                }
            } catch (error) {
                console.error(`Error in confirmAction: ${error.message}`);
            }
        }
        
        // Steam path handling
        function updateSteamPath(path) {
    const steamPathElement = document.getElementById('steam-path');
    if (steamPathElement) {
        steamPathElement.textContent = path || 'Not detected';
    }
    
    // Store the steam path globally for other functions to use
    window.detectedSteamPath = path || '';
    
    // If we found a steam path but have no games, show empty state
    if (path && (!allGames || allGames.length === 0)) {
        console.log("Steam path detected but no games loaded");
        // Don't auto-scan, just show the empty state
        showGamesEmptyState();
    }
}
        
        function refreshSteamPath() {
            const steamPathElement = document.getElementById('steam-path');
            if (steamPathElement) {
                steamPathElement.textContent = 'Detecting...';
                
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage('getSteamPath');
                }
            }
        }
        
        // Plugin status handling
        function updatePluginStatus(status) {
            const pluginStatusElement = document.getElementById('plugin-status');
            const repairBtn = document.getElementById('repair-plugin-btn');
            const restartBtn = document.getElementById('restart-steam-btn');

            if (pluginStatusElement) {
                pluginStatusElement.textContent = status || 'Unknown';

                // Color code the status and show/hide repair button
                let pluginOk = false;
                if (status === 'Detected') {
                    pluginStatusElement.style.color = '#4CAF50'; // Green
                    if (repairBtn) repairBtn.style.display = 'none';
                    pluginOk = true;
                } else if (status === 'Partially' || status.includes('Partial')) {
                    pluginStatusElement.style.color = '#FFC107'; // Amber
                    if (repairBtn) repairBtn.style.display = 'inline-flex';
                    pluginOk = false;
                } else if (status === 'Not installed' || status.includes('Not')) {
                    pluginStatusElement.style.color = '#F44336'; // Red
                    if (repairBtn) repairBtn.style.display = 'inline-flex';
                    pluginOk = false;
                } else {
                    pluginStatusElement.style.color = '#9E9E9E'; // Gray
                    if (repairBtn) repairBtn.style.display = 'none';
                    pluginOk = false;
                }

                // Update restart button state based on plugin status
                if (restartBtn) {
                    const swaEnabled = document.getElementById('enable-swa')?.checked ?? true;
                    const canRestart = swaEnabled && pluginOk;

                    if (canRestart) {
                        restartBtn.classList.remove('disabled');
                        restartBtn.onmouseenter = null;
                        restartBtn.onmouseleave = null;
                        restartBtn.onmousemove = null;
                    } else {
                        restartBtn.classList.add('disabled');
                        restartBtn.onmouseenter = showRestartTooltip;
                        restartBtn.onmouseleave = hideRestartTooltip;
                        restartBtn.onmousemove = moveRestartTooltip;
                    }
                }
            }
        }

        function repairPlugin() {
            console.log('repairPlugin() called');

            // Show visual feedback
            if (typeof showNotification === 'function') {
                showNotification('Installing plugin components...', 'info');
            }

            if (window.chrome && window.chrome.webview) {
                console.log('Sending repairPlugin message to backend');
                window.chrome.webview.postMessage('repairPlugin');
            } else {
                console.error('WebView not available');
                if (typeof showNotification === 'function') {
                    showNotification('Error: WebView not available', 'error');
                }
            }
        }
        
        function openDevTools() {
            console.log('Opening DevTools...');
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('open-devtools');
                console.log('DevTools message sent');
            } else {
                console.error('WebView not available');
            }
        }

        function refreshPlugin() {
            const pluginStatusElement = document.getElementById('plugin-status');
            if (pluginStatusElement) {
                pluginStatusElement.textContent = 'Detecting...';
                pluginStatusElement.style.color = '';
                
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage('checkPlugin');
                }
            }
        }
        
        // Games detection and display
        let allGames = []; // Store all games
        let filteredGames = []; // Store filtered games (after search)
        let currentGames = []; // Store current page's game objects
        let currentPage = 1;
        const gamesPerPage = 3; // Number of games to display per page
        let gameDetailsCache = {}; // Cache for game details from API

        // Games loading tracking
        let gamesLoadingCount = 0; // Number of games currently loading
        let gamesTotalToLoad = 0; // Total games that need to load
        let gamesLoaded = 0; // Number of games that have finished loading
        let pendingGameIds = new Set(); // Track which games are still pending
        let gameRequestTimeouts = {}; // Track timeout timers for each game request

        // IndexedDB Image Cache Setup
        let imageDB = null;
        const IMAGE_CACHE_VERSION = 1;
        const IMAGE_STORE_NAME = 'gameImages';

        function initImageCache() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('SWAImageCache', IMAGE_CACHE_VERSION);

                request.onerror = () => {
                    console.error('Failed to open IndexedDB for image cache');
                    reject(request.error);
                };

                request.onsuccess = () => {
                    imageDB = request.result;
                    console.log('Image cache initialized');
                    resolve();
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(IMAGE_STORE_NAME)) {
                        const store = db.createObjectStore(IMAGE_STORE_NAME, { keyPath: 'gameId' });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log('Image cache store created');
                    }
                };
            });
        }

        async function saveImageToCache(gameId, imageUrl) {
            if (!imageDB) return;

            try {
                // Fetch the image as a blob
                const response = await fetch(imageUrl);
                const blob = await response.blob();

                // Convert blob to base64 for storage
                const base64data = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });

                // Store in IndexedDB
                const transaction = imageDB.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);

                await new Promise((resolve, reject) => {
                    const request = store.put({
                        gameId: gameId,
                        imageData: base64data,
                        timestamp: Date.now()
                    });
                    request.onsuccess = () => {
                        console.log(`Cached image for game ${gameId}`);
                        resolve();
                    };
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error(`Failed to cache image for game ${gameId}:`, error);
            }
        }

        async function getImageFromCache(gameId) {
            if (!imageDB) return null;

            return new Promise((resolve) => {
                try {
                    const transaction = imageDB.transaction([IMAGE_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(IMAGE_STORE_NAME);
                    const request = store.get(gameId);

                    request.onsuccess = () => {
                        if (request.result) {
                            console.log(`Loaded cached image for game ${gameId}`);
                            resolve(request.result.imageData);
                        } else {
                            resolve(null);
                        }
                    };

                    request.onerror = () => {
                        console.error(`Error loading cached image for game ${gameId}`);
                        resolve(null);
                    };
                } catch (error) {
                    console.error(`Failed to get cached image for game ${gameId}:`, error);
                    resolve(null);
                }
            });
        }

        // Clean up old cached images (older than 30 days)
        async function cleanupOldCachedImages() {
            if (!imageDB) return;

            try {
                const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
                const transaction = imageDB.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const index = store.index('timestamp');
                const request = index.openCursor();

                let deletedCount = 0;

                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        if (cursor.value.timestamp < thirtyDaysAgo) {
                            cursor.delete();
                            deletedCount++;
                        }
                        cursor.continue();
                    } else {
                        if (deletedCount > 0) {
                            console.log(`Cleaned up ${deletedCount} old cached images`);
                        }
                    }
                };

                request.onerror = () => {
                    console.error('Error cleaning up old cached images');
                };
            } catch (error) {
                console.error('Failed to cleanup old cached images:', error);
            }
        }

        // Remove cached images for games that no longer exist
        async function cleanupOrphanedCachedImages() {
            if (!imageDB || !allGames) return;

            try {
                const currentGameIds = new Set(allGames.map(g => g.id));
                const transaction = imageDB.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.openCursor();

                let deletedCount = 0;

                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        if (!currentGameIds.has(cursor.value.gameId)) {
                            cursor.delete();
                            deletedCount++;
                        }
                        cursor.continue();
                    } else {
                        if (deletedCount > 0) {
                            console.log(`Cleaned up ${deletedCount} orphaned cached images`);
                        }
                    }
                };

                request.onerror = () => {
                    console.error('Error cleaning up orphaned cached images');
                };
            } catch (error) {
                console.error('Failed to cleanup orphaned cached images:', error);
            }
        }

        // Initialize image cache on page load and run cleanup
        initImageCache()
            .then(() => {
                // Clean up old cached images on startup
                cleanupOldCachedImages();
            })
            .catch(err => console.error('Image cache init failed:', err));

        // Games loading indicator management
        function showGamesLoadingIndicator() {
            const indicator = document.getElementById('games-loading-indicator');
            if (indicator) {
                indicator.style.display = 'flex';
            }
        }

        function hideGamesLoadingIndicator() {
            const indicator = document.getElementById('games-loading-indicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }

        function updateGamesLoadingProgress() {
            const progressElement = document.getElementById('games-loading-progress');
            if (progressElement && gamesTotalToLoad > 0) {
                progressElement.textContent = `(${gamesLoaded}/${gamesTotalToLoad})`;
            }
        }

        function startGamesLoading(total) {
            gamesTotalToLoad = total;
            gamesLoaded = 0;
            gamesLoadingCount = total;
            showGamesLoadingIndicator();
            updateGamesLoadingProgress();

            // Disable search during loading
            const searchInput = document.getElementById('game-search');
            if (searchInput) {
                searchInput.disabled = true;
                searchInput.placeholder = 'Loading games...';
            }

            // Safety timeout: Force finish after 60 seconds if still stuck
            setTimeout(() => {
                if (gamesLoadingCount > 0) {
                    console.warn(`Loading timeout reached. ${gamesLoadingCount} games still pending. Force finishing.`);
                    gamesLoadingCount = 0;
                    gamesLoaded = gamesTotalToLoad;
                    hideGamesLoadingIndicator();
                    const searchInput = document.getElementById('game-search');
                    if (searchInput) {
                        searchInput.disabled = false;
                        searchInput.placeholder = 'Search games...';
                    }
                }
            }, 60000); // 60 seconds timeout
        }

        function finishGameLoading() {
            gamesLoaded++;
            gamesLoadingCount--;
            console.log(`Game loaded: ${gamesLoaded}/${gamesTotalToLoad} (${gamesLoadingCount} remaining)`);
            updateGamesLoadingProgress();

            // Hide indicator and enable search when all done
            if (gamesLoadingCount <= 0) {
                console.log('All games loaded successfully!');
                hideGamesLoadingIndicator();
                const searchInput = document.getElementById('game-search');
                if (searchInput) {
                    searchInput.disabled = false;
                    searchInput.placeholder = 'Search games...';
                }
            }
        }

        // Preload all games information in background
        function preloadAllGamesInBackground() {
            if (!allGames || allGames.length === 0) return;

            // Extract just the game IDs (remove .luad extension if present)
            const gameIds = allGames.map(gameStr => {
                const gameId = gameStr.toString().replace('.luad', '');
                return gameId;
            });

            console.log(`Starting background preload for ${gameIds.length} games`);

            // Clear pending games set
            pendingGameIds.clear();

            // Start loading indicator for ALL games
            startGamesLoading(gameIds.length);

            // Fetch details for all games in background
            gameIds.forEach(gameId => {
                pendingGameIds.add(gameId);
                fetchGameDetails(gameId);
            });

            // Log pending games after a short delay
            setTimeout(() => {
                if (pendingGameIds.size > 0) {
                    console.log(`Still pending: ${Array.from(pendingGameIds).join(', ')}`);
                }
            }, 5000);
        }

        function scanGames() {
            // Clear existing games
            allGames = [];
            filteredGames = [];
            currentPage = 1;
            
            // Do not clear the cache, to preserve it between scans
            // clearGameDetailsCache();
            
            const gamesContainer = document.getElementById('games-container');
            if (gamesContainer) {
                gamesContainer.innerHTML = '<div class="loading-indicator">Scanning for games...</div>';
                gamesContainer.style.display = 'block';
                document.getElementById('games-empty-state').style.display = 'none';
            }
            
            // Hide pagination controls during scan
            document.getElementById('pagination-controls').style.display = 'none';
            
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('scanGames');
            }
        }

        function showGamesEmptyState() {
            // Update the summary to show "Found 0 games" without scanning
            const gamesSummary = document.getElementById('games-summary');
            if (gamesSummary) {
                gamesSummary.innerHTML = '<i class="fas fa-exclamation-circle"></i> Found 0 games';
                gamesSummary.classList.add('no-games');
            }
            
            // Show the empty state container if it exists
            const gamesContainer = document.getElementById('games-container');
            const emptyState = document.getElementById('games-empty-state');
            
            if (gamesContainer) {
                gamesContainer.style.display = 'none';
            }
            
            if (emptyState) {
                emptyState.style.display = 'block';
            }
            
            // Hide pagination controls
            const paginationControls = document.getElementById('pagination-controls');
            if (paginationControls) {
                paginationControls.style.display = 'none';
            }
        }
        
        // Function to clear game details cache
        function clearGameDetailsCache() {
            gameDetailsCache = {};
            console.log("Game details cache cleared");
        }

        function updateGamesSummary() {
            const gamesSummary = document.getElementById('games-summary');
            if (gamesSummary) {
                console.log("Force updating games summary. Current allGames length:", allGames ? allGames.length : 0);
                if (allGames && allGames.length > 0) {
                    gamesSummary.innerHTML = `<i class="fas fa-gamepad"></i> Found ${allGames.length} game${allGames.length === 1 ? '' : 's'}`;
                    gamesSummary.classList.remove('no-games');
                } else {
                    gamesSummary.innerHTML = '<i class="fas fa-exclamation-circle"></i> Found 0 games';
                    gamesSummary.classList.add('no-games');
                }
            } else {
                console.error("games-summary element not found in updateGamesSummary!");
            }
        }
        
        function updateGamesList(gameData) {
    // If gameData is an array of game objects (from C# backend)
    if (Array.isArray(gameData) && gameData.length > 0 && typeof gameData[0] === 'object') {
        console.log("Received gameData objects:", gameData);
        
        // Store all game data in a map for easy access
        const gameDataMap = {};
        gameData.forEach(game => {
            if (game.id) {
                gameDataMap[game.id] = {
                    enabled: game.enabled,
                    lastUpdate: game.last_update || "",
                    fileType: game.fileType
                };
            }
        });
        
        // Extract numerical game IDs only
        allGames = gameData
            .filter(game => /^\d+$/.test(game.id)) // Filter for numeric IDs only
            .map(game => {
                const gameId = game.id;
                return gameId + (game.enabled ? '' : '.luad'); // Add .luad extension for disabled games
            });
            
        // Store the game data map for later use when rendering
        window.gameDataMap = gameDataMap;
    } else {
        // Fallback for simple string array format
        allGames = Array.isArray(gameData) ? gameData : [];
        window.gameDataMap = {};
    }
    
    console.log("Processed game data:", allGames);
    console.log("Total games found:", allGames ? allGames.length : 0);
    filteredGames = [...allGames];
    currentPage = 1;
    
    const gamesSummary = document.getElementById('games-summary');
    
    // Update the summary with debugging
    if (gamesSummary) {
        console.log("Updating games summary with count:", allGames ? allGames.length : 0);
        if (allGames && allGames.length > 0) {
            gamesSummary.innerHTML = `<i class="fas fa-gamepad"></i> Found ${allGames.length} game${allGames.length === 1 ? '' : 's'}`;
            gamesSummary.classList.remove('no-games');
            console.log("Games summary updated to show", allGames.length, "games");
        } else {
            gamesSummary.innerHTML = '<i class="fas fa-exclamation-circle"></i> Found 0 games';
            gamesSummary.classList.add('no-games');
            console.log("Games summary updated to show 0 games");
        }
    } else {
        console.error("games-summary element not found!");
    }
    
    // Update valid game files in debug
    if (typeof updateValidGameFiles === 'function') {
        updateValidGameFiles(allGames);
    }
    
    // Force update summary
    updateGamesSummary();

    // Clean up cached images for games that no longer exist
    cleanupOrphanedCachedImages();

    // Start background loading for ALL games
    preloadAllGamesInBackground();

    // Render the first page
    renderGamesPage();
}
        
        // Function to get the appropriate class for color coding update dates
        function colorCodeUpdateDate(gameId, localLastUpdate) {
            // If we don't have a local update date, return empty class
            if (!localLastUpdate) return '';
            
            // Get API last update from cached game details
            const apiLastUpdate = gameDetailsCache[gameId]?.last_update;
            
            // If we don't have API data yet, return empty class
            if (!apiLastUpdate) return '';
            
            // Compare dates and return appropriate class
            return localLastUpdate === apiLastUpdate ? 'matching' : 'outdated';
        }
        
        function renderGamesPage() {
    const gamesContainer = document.getElementById('games-container');
    const emptyState = document.getElementById('games-empty-state');
    const paginationControls = document.getElementById('pagination-controls');
    
    if (!gamesContainer) return;
    
    console.log("Rendering games page with", filteredGames ? filteredGames.length : 0, "games");
    
    if (!filteredGames || filteredGames.length === 0) {
        gamesContainer.style.display = 'none';
        emptyState.style.display = 'block';
        paginationControls.style.display = 'none';
        return;
    }
            
    // Hide empty state and show games
    emptyState.style.display = 'none';
    gamesContainer.style.display = 'block';
    
    // Calculate pagination
    const totalPages = Math.ceil(filteredGames.length / gamesPerPage);
    if (currentPage > totalPages) currentPage = totalPages;
    
    // Update pagination controls
    if (totalPages > 1) {
        paginationControls.style.display = 'flex';
        document.getElementById('page-input').value = currentPage;
        document.getElementById('total-pages-display').textContent = `/ ${totalPages}`;
        document.getElementById('prev-page-btn').disabled = currentPage === 1;
        document.getElementById('next-page-btn').disabled = currentPage === totalPages;
    } else {
        paginationControls.style.display = 'none';
    }
    
    // Calculate start and end indices for current page
    const startIndex = (currentPage - 1) * gamesPerPage;
    const endIndex = Math.min(startIndex + gamesPerPage, filteredGames.length);
    
    // Clear previous content
    gamesContainer.innerHTML = '';
    
    // Convert filtered games to game objects for current page
    const currentGames = [];
    for (let i = startIndex; i < endIndex; i++) {
        const gameId = filteredGames[i];
        const isEnabled = !gameId.endsWith('.luad');
        const pureGameId = gameId.replace('.luad', '');
        
        // Get any stored data from gameDataMap
        let lastUpdate = "";
        if (window.gameDataMap && window.gameDataMap[pureGameId]) {
            lastUpdate = window.gameDataMap[pureGameId].lastUpdate || "";
        }
        
        currentGames.push({
            id: pureGameId,
            enabled: isEnabled,
            name: "", // Will be populated from API
            lastUpdate: lastUpdate
        });
    }
    
    // Build HTML for all games on current page
    let gamesHTML = '';
    currentGames.forEach(game => {
        const gameEnabled = game.enabled;
        // Use a data URI placeholder instead of external URL to avoid network errors
        const backupImage = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='100'%3E%3Crect fill='%231a1a1a' width='180' height='100'/%3E%3Ctext fill='%23666' font-family='Arial' font-size='12' x='50%25' y='50%25' text-anchor='middle' dominant-baseline='middle'%3EGame ${game.id}%3C/text%3E%3C/svg%3E`;
        
        // Check if we already know game needs update from the cache
        let updateBtnStyle = "display: none;";
        const cachedDetails = gameDetailsCache[game.id];
        if (cachedDetails && game.lastUpdate && cachedDetails.last_update) {
            try {
                // Parse stored date (DD.MM.YYYY HH:MM format)
                const storedDate = new Date(game.lastUpdate.replace(/(\d+)\.(\d+)\.(\d+) (\d+):(\d+)/, "$3-$2-$1T$4:$5:00"));
                
                // Parse API date
                let apiDate;
                if (cachedDetails.last_update.includes('T')) {
                    apiDate = new Date(cachedDetails.last_update);
                } else {
                    apiDate = new Date(`${cachedDetails.last_update}T00:00:00`);
                }
                
                // If API date is more recent, show update button
                if (storedDate < apiDate) {
                    updateBtnStyle = "display: flex;";
                }
            } catch (error) {
                console.error(`Error comparing dates for game ${game.id}:`, error);
            }
        }
        
        gamesHTML += `
        <div class="game-card redesigned" data-id="${game.id}" data-enabled="${gameEnabled}">
            <div class="game-img-col">
                <img class="game-img" src="${backupImage}" alt="Game ${game.id}" loading="lazy" />
                <div class="game-img-overlay"></div>
                <div class="game-img-loading"><i class="fas fa-sync fa-spin"></i></div>
                ${!gameEnabled ? '<div class="disabled-game-overlay"><span class="disabled-game-text">Disabled</span></div>' : ''}
            </div>
            <div class="game-info-col">
                <div class="game-card-header">
                    <div class="game-title-row">
                        <h3 class="game-name">${game.name || `Game ${game.id}`}</h3>
                        <div id="developer-${game.id}" class="game-developer">Loading...</div>
                    </div>
                </div>
                
                <div class="game-meta-tags" id="game-meta-${game.id}">
                    <div class="meta-tag loading">Loading details...</div>
                </div>
                <button class="action-toggle action-corner" onclick="toggleActionMenu(event, 'action-menu-${game.id}')">
                    <i class="fas fa-ellipsis-v"></i>
                </button>
                <button class="update-action-btn" id="update-btn-${game.id}" onclick="updateGame('${game.id}')">
                    <i class="fas fa-sync-alt"></i>
                </button>
            </div>
            
            <div class="game-controls-col">
                <button class="update-btn" onclick="updateGame('${game.id}')" style="${updateBtnStyle}">
                    <i class="fas fa-sync-alt"></i>
                </button>
            </div>

            <!-- Add last update date display -->
            <div class="last-update-date ${colorCodeUpdateDate(game.id, game.lastUpdate)}">
                ${game.lastUpdate ? `${game.lastUpdate}` : 'No update date'}
            </div>
            
            <div class="action-menu" id="action-menu-${game.id}">
                <div class="action-item toggle-item" onclick="toggleGame('${game.id}', ${!gameEnabled}); closeAllMenus();">
                    <span>${gameEnabled ? 'Disable Game' : 'Enable Game'}</span>
                    <i class="fas fa-${gameEnabled ? 'toggle-off' : 'toggle-on'}"></i>
                </div>
                <div class="action-item danger" onclick="try { removeGame('${game.id}'); } catch(e) { console.error(e); removeGameConfirmed('${game.id}'); } finally { closeAllMenus(); }">
                    <span>Remove Game</span>
                    <i class="fas fa-trash"></i>
                </div>
                <div class="game-id-display">
                    <span class="game-id-label">ID:</span>
                    <span class="game-id-value">${game.id}</span>
                </div>
            </div>
        </div>`;
    });
    
    // Set HTML content
    gamesContainer.innerHTML = gamesHTML;

    // Update game cards from cache if available
    // Background loading will fetch any missing data
    currentGames.forEach(game => {
        const cachedDetails = gameDetailsCache[game.id];
        if (cachedDetails) {
            // Already have data in cache - update card immediately
            updateGameCard(game.id, cachedDetails);
        }
        // If not in cache, background loading will handle it
    });
    
    // Set update button visibility based on cached data
    setTimeout(checkAndShowUpdateButton, 100);
    
    // Ensure games summary is up to date
    updateGamesSummary();
}
        
        function searchGames() {
            const searchInput = document.getElementById('game-search');
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.trim().toLowerCase();
            
            if (!searchTerm) {
                // If search is empty, show all games
                filteredGames = [...allGames];
            } else {
                // Filter games based on search term
                filteredGames = allGames.filter(gameIdWithExt => {
                    const pureGameId = gameIdWithExt.replace('.luad', '');
                    
                    // 1. Check against game ID
                    const idMatch = pureGameId.toLowerCase().includes(searchTerm);
                    
                    // 2. Check against game name from cache
                    const cachedDetails = gameDetailsCache[pureGameId];
                    const nameMatch = cachedDetails && cachedDetails.name && 
                                      cachedDetails.name.toLowerCase().includes(searchTerm);
                    
                    return idMatch || nameMatch;
                });
            }
            
            // Reset to first page and render
            currentPage = 1;
            renderGamesPage();
        }
        
        function changePage(delta) {
            const newPage = currentPage + delta;
            const totalPages = Math.ceil(filteredGames.length / gamesPerPage);
            
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                renderGamesPage();
            }
        }
        
        function handlePageJump(event) {
            if (event.key === 'Enter') {
                const input = event.target;
                const newPage = parseInt(input.value, 10);
                const totalPages = Math.ceil(filteredGames.length / gamesPerPage);

                if (!isNaN(newPage) && newPage >= 1 && newPage <= totalPages) {
                    currentPage = newPage;
                    renderGamesPage();
                } else {
                    // Reset to current page if input is invalid
                    input.value = currentPage;
                }
                input.blur(); // Remove focus from input
            }
        }
        
        function toggleGame(gameId, shouldEnable) {
            console.log(`Toggling game ${gameId} to ${shouldEnable ? 'enabled' : 'disabled'}`);
            
            // Send message to C# to toggle game
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`toggleGame:${gameId}:${shouldEnable}`);
                
                // Update the UI immediately to reflect the change
                const gameCard = document.querySelector(`.game-card[data-id="${gameId}"]`);
                if (gameCard) {
                    // Update the data-enabled attribute
                    gameCard.setAttribute('data-enabled', shouldEnable.toString());
                    
                    // Update the disabled overlay
                    const overlay = gameCard.querySelector('.disabled-game-overlay');
                    if (shouldEnable) {
                        // Remove overlay if enabling
                        if (overlay) {
                            overlay.remove();
                        }
                    } else {
                        // Add overlay if disabling
                        if (!overlay) {
                            const imgCol = gameCard.querySelector('.game-img-col');
                            if (imgCol) {
                                const newOverlay = document.createElement('div');
                                newOverlay.className = 'disabled-game-overlay';
                                newOverlay.innerHTML = '<span class="disabled-game-text">Disabled</span>';
                                imgCol.appendChild(newOverlay);
                            }
                        }
                    }
                    
                    // Find and update the action menu for this game
                    const actionMenu = document.getElementById(`action-menu-${gameId}`);
                    if (actionMenu) {
                        const toggleItem = actionMenu.querySelector('.toggle-item');
                        if (toggleItem) {
                            // Update the onclick handler
                            toggleItem.setAttribute('onclick', `toggleGame('${gameId}', ${!shouldEnable}); closeAllMenus();`);
                            
                            // Update the icon
                            const icon = toggleItem.querySelector('i');
                            if (icon) {
                                icon.className = `fas fa-${shouldEnable ? 'toggle-off' : 'toggle-on'}`;
                            }
                            
                            // Update the text
                            const span = toggleItem.querySelector('span');
                            if (span) {
                                span.textContent = shouldEnable ? 'Disable Game' : 'Enable Game';
                            }
                        }
                    }
                }
                
                // Update the game ID in the filteredGames array
                const index = filteredGames.findIndex(g => g.replace('.luad', '') === gameId);
                if (index !== -1) {
                    filteredGames[index] = shouldEnable ? gameId : `${gameId}.luad`;
                }
            }
        }
        
        // Function to fetch game details from API
        function fetchGameDetails(gameId) {
            const cachedDetails = gameDetailsCache[gameId];
            const localGameInfo = window.gameDataMap?.[gameId];

            // Use cache only if the last update dates match.
            // This prevents using stale data while avoiding re-loading for unchanged games.
            if (cachedDetails && localGameInfo && cachedDetails.last_update === localGameInfo.lastUpdate) {
                console.log(`Using valid cache for game ${gameId}`);
                pendingGameIds.delete(gameId); // Remove from pending
                updateGameCard(gameId, cachedDetails);
                finishGameLoading(); // Mark as loaded since we're using cache
                return;
            }

            if (cachedDetails) {
                console.log(`Stale cache for ${gameId}: API date (${cachedDetails.last_update}) vs. local date (${localGameInfo?.lastUpdate}). Re-fetching.`);
            }

            // Instead of making direct API call, send message to C# backend
            console.log(`Requesting game details for ${gameId} from backend`);
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`fetchGameInfo:${gameId}`);

                // Show loading state
                const gameCard = document.querySelector(`.game-card[data-id="${gameId}"]`);
                if (gameCard) {
                    gameCard.classList.add('loading');
                }

                // Set a timeout for this specific game request (10 seconds)
                gameRequestTimeouts[gameId] = setTimeout(() => {
                    if (pendingGameIds.has(gameId)) {
                        console.warn(`Timeout waiting for game ${gameId} from backend. Marking as finished.`);
                        pendingGameIds.delete(gameId);
                        finishGameLoading();
                    }
                }, 10000); // 10 seconds per game
            } else {
                console.error("WebView2 not available for communication with backend");
                pendingGameIds.delete(gameId); // Remove from pending
                updateGameCardError(gameId);
                finishGameLoading(); // Mark as finished even on error
            }
        }
        
        // Function to process game info received from C# backend
        function processGameInfo(gameData, gameId) {
            console.log(`Received game info from backend for ${gameId}`);

            try {
                // Clear timeout for this game
                if (gameRequestTimeouts[gameId]) {
                    clearTimeout(gameRequestTimeouts[gameId]);
                    delete gameRequestTimeouts[gameId];
                }

                // Remove from pending set
                pendingGameIds.delete(gameId);

                // Cache the data
                gameDetailsCache[gameId] = gameData;

                // Proactively cache the image if not already cached
                if (gameData.image) {
                    getImageFromCache(gameId).then(cachedImage => {
                        if (!cachedImage) {
                            // Not in cache yet - save it proactively
                            console.log(`Proactively caching image for existing game ${gameId}`);
                            saveImageToCache(gameId, gameData.image);
                        }
                    });
                }

                // Update the game card with fetched details
                updateGameCard(gameId, gameData);

                // Mark this game as loaded
                finishGameLoading();

                // Check and update any update buttons
                setTimeout(checkAndShowUpdateButton, 100);
            } catch (error) {
                console.error(`Error processing game data for ${gameId}:`, error);
                pendingGameIds.delete(gameId); // Remove even on error
                updateGameCardError(gameId);
                finishGameLoading(); // Still mark as finished even on error
            }
        }
        
        // Function to handle errors when fetching game info
        function processGameInfoError(gameId, errorMessage) {
            console.error(`Error fetching game info for ${gameId}: ${errorMessage}`);

            // Clear timeout for this game
            if (gameRequestTimeouts[gameId]) {
                clearTimeout(gameRequestTimeouts[gameId]);
                delete gameRequestTimeouts[gameId];
            }

            // Remove from pending set
            pendingGameIds.delete(gameId);

            // Check if we already have data in the cache - don't show error if we do
            if (gameDetailsCache[gameId]) {
                console.log(`Ignoring error for ${gameId} since we have data in cache`);
                finishGameLoading(); // Still mark as finished
                return;
            }

            // Otherwise, update the card with error state
            updateGameCardError(gameId);
            finishGameLoading(); // Mark as finished even on error
        }
        
        // Function to update game card with API data
        function updateGameCard(gameId, gameData) {
            const gameCard = document.querySelector(`.game-card[data-id="${gameId}"]`);
            if (!gameCard) return;
            
            // Remove loading state
            gameCard.classList.remove('loading');
            
            // Get game name or use ID if not available
            const gameName = gameData.name || `Game ${gameId}`;
            
            // Update game name
            const nameElement = gameCard.querySelector('.game-name');
            if (nameElement) {
                nameElement.textContent = gameName;
            }
            
            // Update developer info under the title
            const developerElement = document.getElementById(`developer-${gameId}`);
            if (developerElement) {
                if (gameData.developers && gameData.developers.length > 0) {
                    // Take just the first developer
                    const firstDeveloper = gameData.developers[0];
                    developerElement.textContent = firstDeveloper;
                    developerElement.classList.add('loaded');
                } else {
                    developerElement.textContent = 'Unknown Developer';
                    developerElement.classList.add('unknown');
                }
            }
            
            // Update game image if available
            if (gameData.image) {
                const imgElement = gameCard.querySelector('.game-img');
                if (imgElement) {
                    // Try to load from cache first
                    getImageFromCache(gameId).then(cachedImage => {
                        if (cachedImage) {
                            // Found in cache - display immediately
                            console.log(`Loading image from cache for game ${gameId}`);
                            imgElement.src = cachedImage;
                            // Hide loading indicator
                            const loadingElement = gameCard.querySelector('.game-img-loading');
                            if (loadingElement) {
                                loadingElement.style.display = 'none';
                            }
                        } else {
                            // Not in cache - load from network
                            console.log(`Loading image from network for game ${gameId}`);
                            const img = new Image();
                            img.onload = function() {
                                imgElement.src = gameData.image;
                                // Save to cache for next time
                                saveImageToCache(gameId, gameData.image);
                                // Hide loading indicator
                                const loadingElement = gameCard.querySelector('.game-img-loading');
                                if (loadingElement) {
                                    loadingElement.style.display = 'none';
                                }
                            };
                            img.onerror = function() {
                                // Keep default image on error
                                console.error(`Failed to load image for game ${gameId}`);
                                // Hide loading indicator
                                const loadingElement = gameCard.querySelector('.game-img-loading');
                                if (loadingElement) {
                                    loadingElement.style.display = 'none';
                                }
                            };
                            img.src = gameData.image;
                        }
                    }).catch(err => {
                        console.error(`Cache error for game ${gameId}, falling back to network:`, err);
                        // Fallback to network on cache error
                        const img = new Image();
                        img.onload = function() {
                            imgElement.src = gameData.image;
                            // Hide loading indicator
                            const loadingElement = gameCard.querySelector('.game-img-loading');
                            if (loadingElement) {
                                loadingElement.style.display = 'none';
                            }
                        };
                        img.onerror = function() {
                            console.error(`Failed to load image for game ${gameId}`);
                            const loadingElement = gameCard.querySelector('.game-img-loading');
                            if (loadingElement) {
                                loadingElement.style.display = 'none';
                            }
                        };
                        img.src = gameData.image;
                    });
                }
            } else {
                // No image available for this game - use placeholder
                console.log(`No image available for game ${gameId}, using placeholder`);
                // Hide loading indicator if no image
                const loadingElement = gameCard.querySelector('.game-img-loading');
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
            }
            
            // Update meta tags - only with genres now, since developer is moved
            const metaTagsElement = document.getElementById(`game-meta-${gameId}`);
            if (metaTagsElement) {
                let metaTagsHTML = '';
                
                // Add genres tags - limited to 2 maximum
                if (gameData.genres && gameData.genres.length > 0) {
                    // Only take up to 2 genres
                    const limitedGenres = gameData.genres.slice(0, 2);
                    
                    const genres = limitedGenres.map(genre => {
                        // Get genre name (could be in .description or directly in the object)
                        const genreName = genre.description || genre;
                        
                        // Assign a class based on genre type for styling
                        let genreClass = 'genre';
                        const lowerGenre = genreName.toLowerCase();
                        
                        if (lowerGenre.includes('action')) genreClass += ' action';
                        else if (lowerGenre.includes('casual')) genreClass += ' casual';
                        else if (lowerGenre.includes('rpg') || lowerGenre.includes('role')) genreClass += ' rpg';
                        else if (lowerGenre.includes('adventure')) genreClass += ' adventure';
                        
                        return `<div class="meta-tag ${genreClass}"><i class="fas fa-tag"></i> ${genreName}</div>`;
                    });
                    
                    metaTagsHTML += genres.join('');
                }


                // Add metacritic score badge
                if (gameData.metacritic && gameData.metacritic.score) {
                    const score = gameData.metacritic.score;
                    
                    // First remove any existing score badge to prevent duplicates
                    const existingScoreBadge = gameCard.querySelector('.score-badge');
                    if (existingScoreBadge) {
                        existingScoreBadge.remove();
                    }
                    
                    // Create the badge element
                    const scoreElement = document.createElement('div');
                    scoreElement.className = 'score-badge';
                    scoreElement.textContent = score;
                    
                    // Always directly apply styles based on score rather than using CSS classes
                    // This prevents inconsistencies with CSS cascade and specificity
                    if (score >= 75) {
                        scoreElement.style.backgroundColor = 'rgba(46, 204, 113, 0.25)';
                        scoreElement.style.color = '#2ecc71';
                        scoreElement.style.border = '1px solid rgba(46, 204, 113, 0.4)';
                    } else if (score >= 50) {
                        scoreElement.style.backgroundColor = 'rgba(243, 156, 18, 0.25)';
                        scoreElement.style.color = '#f39c12';
                        scoreElement.style.border = '1px solid rgba(243, 156, 18, 0.4)';
                    } else {
                        scoreElement.style.backgroundColor = 'rgba(231, 76, 60, 0.25)';
                        scoreElement.style.color = '#e74c3c';
                        scoreElement.style.border = '1px solid rgba(231, 76, 60, 0.4)';
                    }
                    
                    // Add the score badge to the game card
                    gameCard.appendChild(scoreElement);
                    
                    // Make the score badge immediately visible (no transition needed)
                    // This improves consistency between page loads and navigation
                    scoreElement.style.opacity = '1';
                }
                
                // Update the meta tags container
                metaTagsHTML = metaTagsHTML || '<div class="meta-tag">No genres available</div>';
                metaTagsElement.innerHTML = metaTagsHTML;
            }

            // Add DRM and Launcher badges to game image area
            const gameImgCol = gameCard.querySelector('.game-img-col');
            if (gameImgCol) {
                // Remove existing badges to prevent duplicates
                const existingBadges = gameImgCol.querySelectorAll('.drm-badge, .launcher-badge');
                existingBadges.forEach(badge => badge.remove());

                const hasDRM = gameData.drm_notice && gameData.drm_notice.trim() !== '';
                const hasLauncher = gameData.ext_user_account_notice && gameData.ext_user_account_notice.trim() !== '';

                // Add DRM badge if present
                if (hasDRM) {
                    const drmBadge = document.createElement('div');
                    drmBadge.className = 'drm-badge';
                    drmBadge.setAttribute('data-tooltip-title', 'DRM Protection');
                    drmBadge.setAttribute('data-tooltip-content', gameData.drm_notice);
                    drmBadge.innerHTML = '<i class="fas fa-shield-alt"></i>';
                    drmBadge.onmouseenter = showBadgeTooltip;
                    drmBadge.onmousemove = moveBadgeTooltip;
                    drmBadge.onmouseleave = hideBadgeTooltip;
                    gameImgCol.appendChild(drmBadge);
                }

                // Add Launcher badge if present
                if (hasLauncher) {
                    const launcherBadge = document.createElement('div');
                    // If no DRM badge, position launcher at the first position
                    launcherBadge.className = hasDRM ? 'launcher-badge' : 'launcher-badge first-badge';
                    launcherBadge.setAttribute('data-tooltip-title', 'External Launcher');
                    launcherBadge.setAttribute('data-tooltip-content', gameData.ext_user_account_notice);
                    launcherBadge.innerHTML = '<i class="fas fa-rocket"></i>';
                    launcherBadge.onmouseenter = showBadgeTooltip;
                    launcherBadge.onmousemove = moveBadgeTooltip;
                    launcherBadge.onmouseleave = hideBadgeTooltip;
                    gameImgCol.appendChild(launcherBadge);
                }
            }

            // Store last update date for future comparisons
            if (gameData.last_update) {
                const gameObj = currentGames.find(g => g.id === gameId);
                if (gameObj) {
                    gameObj.lastUpdate = gameData.last_update;
                }
                
                // Update the color of the last update date element
                const lastUpdateElement = gameCard.querySelector('.last-update-date');
                if (lastUpdateElement) {
                    // Get local last update from gameDataMap
                    const localLastUpdate = window.gameDataMap && window.gameDataMap[gameId] ? 
                        window.gameDataMap[gameId].lastUpdate : '';
                    
                    // Remove existing classes
                    lastUpdateElement.classList.remove('matching', 'outdated');
                    
                    if (localLastUpdate) {
                        console.log(`Comparing dates for game ${gameId}: Local=${localLastUpdate}, API=${gameData.last_update}`);
                        
                        // Compare dates and add appropriate class
                        if (localLastUpdate === gameData.last_update) {
                            // Dates match - green
                            lastUpdateElement.classList.add('matching');
                        } else {
                            // Dates don't match - red
                            lastUpdateElement.classList.add('outdated');
                            console.log(`Game ${gameId} has different update dates. Local: ${localLastUpdate}, API: ${gameData.last_update}`);
                        }
                    }
                }
            }
            
            // Just to be safe, notify the backend that the game info was successfully processed
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`gameInfoProcessed:${gameId}`);
            }
            
            // Check and update the update button visibility
            checkAndShowUpdateButton();
        }
        
        // Function to update game card with error state
        function updateGameCardError(gameId) {
            const gameCard = document.querySelector(`.game-card[data-id="${gameId}"]`);
            if (!gameCard) return;
            
            // Remove loading state and add error class
            gameCard.classList.remove('loading');
            gameCard.classList.add('error');
            
            // Update meta tags with error
            const metaTagsElement = document.getElementById(`game-meta-${gameId}`);
            if (metaTagsElement) {
                metaTagsElement.innerHTML = '<div class="meta-tag error"><i class="fas fa-exclamation-triangle"></i> Error loading details</div>';
            }
            
            // Hide loading indicator for image
            const loadingElement = gameCard.querySelector('.game-img-loading');
            if (loadingElement) {
                loadingElement.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
            }
        }
        
        // Game action menu functions
        function toggleActionMenu(event, menuId) {
            event.stopPropagation();
            event.preventDefault();
            
            const menu = document.getElementById(menuId);
            if (!menu) return;
            
            // Close all other open menus first
            document.querySelectorAll('.action-menu.show').forEach(openMenu => {
                if (openMenu.id !== menuId) {
                    openMenu.classList.remove('show');
                }
            });
            
            // Toggle this menu
            const wasShowing = menu.classList.contains('show');
            
            if (wasShowing) {
                menu.classList.remove('show');
                document.removeEventListener('click', closeMenuOnClickOutside);
            } else {
                menu.classList.add('show');
                
                // Position the menu
                const button = event.currentTarget;
                const buttonRect = button.getBoundingClientRect();
                
                // Reset any previous positioning
                menu.style.top = '';
                menu.style.bottom = '';
                menu.style.left = '';
                menu.style.right = '';
                
                // Move to end of body for proper z-index
                document.body.appendChild(menu);
                
                // Force a reflow to get accurate measurements
                void menu.offsetWidth;
                
                // Get dimensions after appending to body
                const menuRect = menu.getBoundingClientRect();
                
                // Position menu to the right of the button
                menu.style.top = `${buttonRect.top + buttonRect.height + 5}px`;
                menu.style.right = `${document.documentElement.clientWidth - buttonRect.right}px`;
                
                // Add a click outside listener to close the menu
                setTimeout(() => {
                    document.addEventListener('click', closeMenuOnClickOutside);
                }, 10);
            }
        }
        
        function closeMenuOnClickOutside(e) {
            if (!e.target.closest('.action-menu') && !e.target.closest('.action-toggle')) {
                closeAllMenus();
            }
        }
        
        function playGame(gameId) {
            console.log(`Playing game: ${gameId}`);
            // Close all menus
            closeAllMenus();
            // Actual implementation will be added later
        }
        
        function downloadGame(gameId) {
            console.log(`Downloading game: ${gameId}`);
            // Close all menus
            closeAllMenus();
            // Actual implementation will be added later
        }
        
        function updateValidGameFiles(gameIds) {
            const validGameFilesElement = document.getElementById('valid-game-files');
            if (validGameFilesElement) {
                if (!gameIds || gameIds.length === 0) {
                    validGameFilesElement.textContent = 'None';
                } else {
                    validGameFilesElement.innerHTML = gameIds.map(id => {
                        const pureId = id.endsWith('.lud') ? id.replace('.lud', '') : id;
                        return `<div class="file-item">${pureId}.lua</div>`;
                    }).join('');
                }
            }
        }
        
        function toggleFilesList(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                if (container.style.display === 'block') {
                    container.style.display = 'none';
                } else {
                    container.style.display = 'block';
                }
            }
        }

        // File copy functionality
        let selectedFilePath = '';
        let selectedFileName = '';

        function browseFile() {
            // Request C# to open file browser dialog
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('browseFile');
            }
        }

        function updateSelectedFile(fileName, filePath) {
            selectedFileName = fileName;
            selectedFilePath = filePath;
            
            // Update UI
            const fileInfoElement = document.getElementById('selected-file-info');
            if (fileInfoElement) {
                fileInfoElement.textContent = fileName;
                fileInfoElement.title = filePath; // Show full path on hover
            }
            
            // Enable copy button
            const copyButton = document.getElementById('copy-btn');
            if (copyButton) {
                copyButton.disabled = false;
            }
            
            // Update info message
            updateCopyInfo('File selected. Choose a destination and click "Copy to Steam".');
        }

        function copySelectedFile() {
            if (!selectedFilePath) {
                updateCopyInfo('No file selected. Please browse and select a file first.', 'error');
                return;
            }
            
            // Get selected destination
            const destinationSelect = document.getElementById('destination-folder');
            const destination = destinationSelect ? destinationSelect.value : '';
            
            // Disable copy button during operation
            const copyButton = document.getElementById('copy-btn');
            if (copyButton) {
                copyButton.disabled = true;
                copyButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Copying...</span>';
            }
            
            updateCopyInfo('Copying file to Steam folder...');
            
            // Send message to C# to perform copy
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`copyFile:${destination}`);
            }
        }

        function fileCopyComplete(success, message, destinationPath) {
            // Re-enable copy button
            const copyButton = document.getElementById('copy-btn');
            if (copyButton) {
                copyButton.disabled = false;
                copyButton.innerHTML = '<i class="fas fa-copy"></i> <span>Copy to Steam</span>';
            }
            
            // Update info with result
            updateCopyInfo(message, success ? 'success' : 'error');
            
            // If successful, log some additional information
            if (success && destinationPath) {
                console.log(`File copied to: ${destinationPath}`);
            }
        }

        function updateCopyInfo(message, status = 'info') {
            const infoElement = document.getElementById('copy-info');
            if (infoElement) {
                // Remove previous status classes
                infoElement.classList.remove('info-success', 'info-error', 'info-info');
                
                // Add appropriate status class
                infoElement.classList.add(`info-${status}`);
                
                // Update text
                infoElement.textContent = message;
            }
        }
        
        // Popup functions
        function showAddGamePopup() {
            // Check if rate limit is active
            if (window.rateLimitActive) {
                return; // Don't show popup if rate limited
            }
            
            const popup = document.getElementById('add-game-popup');
            if (popup) {
                popup.style.display = 'flex';
                
                // Focus the input field
                setTimeout(() => {
                    const input = document.getElementById('new-game-id');
                    if (input) input.focus();
                }, 100);
                
                // Add escape key listener
                document.addEventListener('keydown', closePopupOnEscape);
            }
        }
        
        function hideAddGamePopup() {
            const popup = document.getElementById('add-game-popup');
            if (popup) {
                popup.style.display = 'none';
                
                // Clear input
                const input = document.getElementById('new-game-id');
                if (input) input.value = '';
                
                // Remove escape key listener
                document.removeEventListener('keydown', closePopupOnEscape);
            }
        }

        // DLC processing functions
        let isDlcProcessing = false;

        function setDlcProcessing(processing, message = '') {
            isDlcProcessing = processing;
            
            // Disable/enable add button
            const addButton = document.querySelector('button[onclick="addNewGame()"]');
            if (addButton) {
                addButton.disabled = processing;
                if (processing) {
                    addButton.style.opacity = '0.5';
                    addButton.style.cursor = 'not-allowed';
                } else {
                    addButton.style.opacity = '';
                    addButton.style.cursor = '';
                }
            }
            
            // Update log message if provided
            if (message) {
                // Check if message indicates success
                const isSuccess = message.includes('successfully added') || message.includes('unlocked');
                const messageType = isSuccess ? 'success' : 'default';
                updateLogMessage(message, messageType);
            }
        }

        // Unified function to unblock add button
        function unblockAddButton() {
            const addButton = document.querySelector('button[onclick="addNewGame()"]');
            if (addButton) {
                addButton.disabled = false;
                addButton.style.opacity = '';
                addButton.style.cursor = '';
            }
        }

        function updateDlcProgress(current, total, gameName) {
            const message = `Processing DLC for ${gameName}... ${current}/${total}`;
            updateLogMessage(message, 'info');
        }
        
        function closePopupOnEscape(e) {
            if (e.key === 'Escape') {
                hideAddGamePopup();
            }
        }
        
        function addNewGame() {
            // Check if rate limit is active
            if (window.rateLimitActive) {
                return; // Don't allow adding games if rate limited
            }
            
            // Check if DLC processing is active
            if (isDlcProcessing) {
                return; // Don't allow adding games if DLC is being processed
            }
            
            const input = document.getElementById('new-game-id');
            if (!input) return;

            let gameId = input.value.trim();

            // Check if the input is a Steam URL and extract the app ID
            const steamUrlMatch = gameId.match(/store\.steampowered\.com\/app\/(\d+)/);
            if (steamUrlMatch && steamUrlMatch[1]) {
                gameId = steamUrlMatch[1];
            }

            // Validate: must be numeric only
            if (!gameId || !/^\d+$/.test(gameId)) {
                input.style.borderColor = 'var(--danger)';
                // Reset border color after a short delay
                setTimeout(() => {
                    input.style.borderColor = '';
                }, 2000);
                return;
            }

            // Here you would normally add code to download the game file
            // But as per the instructions, this will be implemented later
            console.log(`Adding game with ID: ${gameId}`);
            
            // Update the log message in the title bar
            updateLogMessage(`Searching for game ${gameId}...`);
            
            // Check DLC checkbox state
            const dlcCheckbox = document.getElementById('add-dlcs');
            const includeDlc = dlcCheckbox && dlcCheckbox.checked;
            
            // Send message to C# to add the game
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`addGame:${gameId}:${includeDlc}`);
                
                // Block add button during game addition
                const addButton = document.querySelector('button[onclick="addNewGame()"]');
                if (addButton) {
                    addButton.disabled = true;
                    addButton.style.opacity = '0.5';
                    addButton.style.cursor = 'not-allowed';
                }
            }
            
            // Close the popup
            hideAddGamePopup();
            
            // Show a temporary "adding game" notification
            const gamesSummary = document.getElementById('games-summary');
            if (gamesSummary) {
                const originalText = gamesSummary.textContent;
                gamesSummary.textContent = `Adding game ${gameId}...`;
                gamesSummary.style.color = 'var(--primary)';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    gamesSummary.textContent = originalText;
                    gamesSummary.style.color = '';
                    
                    // Remove redundant scanGames call - this is already handled by C# after adding the game
                    // This prevents a potential request loop between C# and JavaScript
                    // The backend will call ScanPluginGames automatically after adding the game
                }, 2000);
            }
        }
        
        // Initialize event listeners
        function initializeEventListeners() {
            // Prevent page refresh with keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Prevent Ctrl+R (refresh)
                if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                    e.preventDefault();
                    return false;
                }
                
                // Prevent F5 (refresh)
                if (e.key === 'F5') {
                    e.preventDefault();
                    return false;
                }
                
                // Prevent other browser shortcuts
                if ((e.ctrlKey || e.metaKey) && (e.key === 'n' || e.key === 't')) {
                    e.preventDefault();
                    return false;
                }
            });
            
            // Prevent right-click context menu
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                return false;
            });

            // Handle window dragging via title bar
            const titleBar = document.querySelector('.title-bar');
            if (titleBar) {
                titleBar.addEventListener('mousedown', startDrag);
            }
            
            // Add animation to stat cards on page load
            animateStatsCards();
        }
        
        // Initialize on page load
window.addEventListener('load', function() {
    // Initialize version variables - will be updated by the backend
    window.currentVersion = "Unknown";
    window.latestVersion = "Unknown";
    
    // Initialize games arrays
    window.allGames = [];
    window.filteredGames = [];
    
    // Simulate loading progress
    simulateLoading();
    
    // Initialize other components in the background
    initializeEventListeners();
    
    // Load patch notes
    fetchPatchNotes();

    // Apply the current user data
    updateUserInterface();

    // Fetch and initialize rotating banner from API
    fetchBannerData();
    
    // Set up slow loading detection
    setupSlowLoadingDetection();
    
    // Check for app updates
    checkForUpdates(false);
    
    // Request Steam path
    if (window.chrome && window.chrome.webview) {
        window.chrome.webview.postMessage('getSteamPath');
    }
    
    // Scan for games after a short delay (give backend time to initialize)
    setTimeout(function() {
        if (window.chrome && window.chrome.webview) {
            window.chrome.webview.postMessage('scanGames');
        }
    }, 1500);
});
        
        // Version information
        let currentVersion = "Unknown";
        let latestVersion = "Unknown";
        

        
        // Function to check for app updates
        function checkForUpdates(showNotification = false) {
            // Send message to backend to check for updates
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`checkForUpdates:${showNotification}`);
                console.log(`Checking for updates, showNotification=${showNotification}`);
            } else {
                console.error('WebView not available - cannot check for updates');
            }
        }
        
        // Function to handle version comparison (called by the backend)
        function handleVersionComparison(currentVer, latestVer, showNotification) {
            // Update version display
            updateVersionDisplay(currentVer);
            
            // Update global version variables
            window.currentVersion = currentVer;
            window.latestVersion = latestVer;
            
            // Compare versions (simple string comparison for now)
            const updateAvailable = currentVer !== latestVer;
            
            if (updateAvailable) {
                // Show update indicator
                const indicator = document.getElementById('update-indicator');
                if (indicator) {
                    indicator.style.display = 'inline-block';
                }
                
                // If manual check, show notification
                if (showNotification) {
                    showUpdateNotification(currentVer, latestVer);
                }
                
                console.log(`Update available: ${currentVer}  ${latestVer}`);
            } else {
                // Hide update indicator
                const indicator = document.getElementById('update-indicator');
                if (indicator) {
                    indicator.style.display = 'none';
                }
                
                // If it was a manual check, show version match notification
                if (showNotification) {
                    showNoUpdateNotification(currentVer);
                }
                
                console.log(`No updates available. Current version: ${currentVer}`);
            }
        }
        
        // Function to update version display in UI
        function updateVersionDisplay(version) {
            // Update version badge in title bar
            const versionBadge = document.getElementById('version-badge');
            if (versionBadge) {
                versionBadge.textContent = version;
            }
            
            // Update version in settings
            const currentVersionEl = document.getElementById('current-version');
            if (currentVersionEl) {
                currentVersionEl.textContent = version;
            }
        }
        
        // Function to show update notification
        function showUpdateNotification(currentVer, latestVer) {
            // Update text in notification
            const currentVersionEl = document.getElementById('current-version-popup');
            const newVersionEl = document.getElementById('new-version-popup');
            
            if (currentVersionEl) currentVersionEl.textContent = currentVer;
            if (newVersionEl) newVersionEl.textContent = latestVer;
            
            // Show notification popup
            const notification = document.getElementById('update-notification');
            if (notification) {
                notification.style.display = 'flex';
            }
        }
        
        // Function to hide update notification
        function hideUpdateNotification() {
            const notification = document.getElementById('update-notification');
            if (notification) {
                notification.style.display = 'none';
            }
        }
        
        // Function to start download update
        function downloadUpdate() {
            // Hide notification
            hideUpdateNotification();
            
            // Show progress popup
            const progressPopup = document.getElementById('update-progress');
            if (progressPopup) {
                progressPopup.style.display = 'flex';
            }
            
            // Reset progress bar
            const progressBar = document.getElementById('update-progress-bar');
            const progressText = document.getElementById('update-progress-text');
            if (progressBar) progressBar.style.width = '0%';
            if (progressText) progressText.textContent = '0%';
            
            // Send download request to backend
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`downloadUpdate:${latestVersion}`);
            }
        }
        
        // Function to update download progress
        function updateDownloadProgress(progress) {
            const progressBar = document.getElementById('update-progress-bar');
            const progressText = document.getElementById('update-progress-text');
            
            if (progressBar) progressBar.style.width = `${progress}%`;
            if (progressText) progressText.textContent = `${progress}%`;
            
            // If complete, start installation
            if (progress >= 100) {
                setTimeout(() => {
                    // Install update
                    installUpdate();
                }, 1000);
            }
        }
        
        // Function to install the update
        function installUpdate() {
            // Send install command to backend
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('installUpdate');
            }
        }

        // Function to set up slow loading detection
        function setupSlowLoadingDetection() {
            // Show slow loading message after 8 seconds
            setTimeout(function() {
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay && !loadingOverlay.classList.contains('hidden')) {
                    const slowMessage = document.getElementById('loading-slow-message');
                    if (slowMessage) {
                        slowMessage.style.display = 'block';
                        // Force a reflow
                        void slowMessage.offsetWidth;
                        slowMessage.style.opacity = '1';
                    }
                }
            }, 8000);
        }

        // Function to exit the application
        function exitApplication() {
            // Close the application window
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('exit');
            } else {
                // Fallback for when running in a browser
                window.close();
            }
        }
        
        // Simulate loading process
        function simulateLoading() {
            const overlay = document.getElementById('loading-overlay');
            const progressBar = document.getElementById('loading-progress-bar');
            
            // Artificial delay to ensure CSS transitions work properly
            setTimeout(() => {
                // Show progress bar animation but don't hide yet
                progressBar.style.width = '80%';
            }, 500);
        }
        
        // Function to validate that all critical data is loaded
        function isDataFullyLoaded() {
            // Check if username is loaded (not default values)
            const usernameElements = document.querySelectorAll('.username');
            let usernameLoaded = false;
            usernameElements.forEach(element => {
                if (element.textContent &&
                    element.textContent !== 'Loading...' &&
                    element.textContent !== 'User' &&
                    element.textContent.trim() !== '') {
                    usernameLoaded = true;
                }
            });

            // Check if device ID is loaded
            const deviceIdElement = document.getElementById('device-id-value');
            const deviceIdLoaded = deviceIdElement &&
                                   deviceIdElement.textContent !== 'Loading...' &&
                                   deviceIdElement.textContent.trim() !== '';

            // Check if user account info has real data
            const hasUserData = userAccountInfo.username &&
                               userAccountInfo.username !== 'User' &&
                               userAccountInfo.username !== 'Loading...';

            const allDataLoaded = usernameLoaded && deviceIdLoaded && hasUserData;

            console.log('Data validation:', {
                usernameLoaded,
                deviceIdLoaded,
                hasUserData,
                allDataLoaded,
                username: userAccountInfo.username
            });

            return allDataLoaded;
        }

        // Function to update loading status text
        function updateLoadingStatus(message, progress) {
            const loadingText = document.querySelector('.loading-text');
            if (loadingText) {
                loadingText.textContent = message;
            }

            const progressBar = document.getElementById('loading-progress-bar');
            if (progressBar && typeof progress === 'number') {
                progressBar.style.width = progress + '%';
            }

            console.log(`Loading status: ${message} (${progress}%)`);
        }

        // Global promise resolver for endpoint test results
        let endpointTestResolver = null;
        let endpointTestTimeout = null;

        // Global handler for endpoint test results from C#
        window.handleEndpointTestResults = function(results) {
            console.log('Received endpoint test results:', results);

            // Clear timeout
            if (endpointTestTimeout) {
                clearTimeout(endpointTestTimeout);
                endpointTestTimeout = null;
            }

            const failedEndpoints = results.filter(r => !r.success);

            if (failedEndpoints.length > 0) {
                showConnectionError(failedEndpoints);
                if (endpointTestResolver) endpointTestResolver(false);
            } else {
                console.log('All endpoints are reachable');
                if (endpointTestResolver) endpointTestResolver(true);
            }

            endpointTestResolver = null;
        };

        // Function to test all critical endpoints using C# backend (no CORS issues)
        async function testCriticalEndpoints() {
            updateLoadingStatus('Testing server connectivity...', 5);

            return new Promise((resolve) => {
                // Store resolver
                endpointTestResolver = resolve;

                // Request C# backend to test endpoints
                if (window.chrome && window.chrome.webview) {
                    // Request C# to test endpoints
                    console.log('Requesting endpoint tests from C#...');
                    window.chrome.webview.postMessage('test-endpoints');

                    // Timeout after 15 seconds
                    endpointTestTimeout = setTimeout(() => {
                        console.error('Endpoint test timeout');
                        showConnectionError([{
                            name: 'Connection Test',
                            success: false,
                            errorType: 'Timeout',
                            errorCode: 'TEST_TIMEOUT'
                        }]);
                        if (endpointTestResolver) endpointTestResolver(false);
                        endpointTestResolver = null;
                    }, 15000);
                } else {
                    console.error('WebView2 not available for endpoint testing');
                    resolve(true); // Don't block if WebView2 is not available
                }
            });
        }

        // Function to show connection error screen
        function showConnectionError(failedEndpoints) {
            const errorOverlay = document.getElementById('connection-error-overlay');
            const loadingOverlay = document.getElementById('loading-overlay');
            const errorDetails = document.getElementById('error-details');

            // Hide loading screen
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }

            // Build error details WITHOUT exposing URLs
            let details = 'Connection Details:\n\n';
            failedEndpoints.forEach(endpoint => {
                details += `Service: ${endpoint.name}\n`;
                details += `Status: ${endpoint.errorType}\n`;
                details += `Code: ${endpoint.errorCode}\n\n`;
            });

            if (errorDetails) {
                errorDetails.textContent = details;
            }

            // Show error overlay
            if (errorOverlay) {
                errorOverlay.style.display = 'flex';
            }

            console.error('Connection test failed:', failedEndpoints);
        }

        // Function to complete loading (called when data is ready)
        function completeLoading() {
            // Validate that data is actually loaded before hiding
            if (!isDataFullyLoaded()) {
                console.warn('completeLoading called but data not fully loaded yet, waiting...');
                updateLoadingStatus('Waiting for data...', 90);
                // Retry after a short delay
                setTimeout(() => {
                    completeLoading();
                }, 200);
                return;
            }

            console.log('All data validated as loaded, hiding loading screen');
            updateLoadingStatus('Complete!', 100);

            const overlay = document.getElementById('loading-overlay');
            const progressBar = document.getElementById('loading-progress-bar');
            const dashboardContent = document.querySelector('.dashboard-content');

            // Complete the progress bar
            progressBar.style.width = '100%';

            // Show dashboard content first
            if (dashboardContent) {
                dashboardContent.classList.add('loaded');
            }

            // Hide the overlay after a brief delay
            setTimeout(() => {
                overlay.classList.add('hidden');
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 500);
            }, 300);
        }
        
        // Add entrance animation to stats cards
        function animateStatsCards() {
            // No longer used, but kept as a placeholder for potential future animations
            console.log("Homepage animations initialized");
            // Could be repurposed for patch notes animations if needed
        }
        
        // Update plan badge based on user's plan
        function updatePlanBadge() {
            const badge = document.getElementById('plan-badge');
            const userPlan = userAccountInfo.status.toLowerCase();
            const isStandardPlan = userPlan.includes('standard') || userPlan.includes('standart');
            
            if (badge) {
                // Remove all classes first
                badge.classList.remove('premium', 'admin', 'standard');
                
                // Add the appropriate class and text based on plan
                if (userPlan.includes('premium')) {
                    badge.classList.add('premium');
                    badge.textContent = 'Premium';
                } else if (userPlan.includes('admin')) {
                    badge.classList.add('admin');
                    badge.textContent = 'Admin';
                } else {
                    badge.classList.add('standard');
                    badge.textContent = 'Standard';
                }
                
                // Add entrance animation
                badge.style.opacity = '0';
                badge.style.transform = 'scale(0.8)';
                badge.style.transition = 'all 0.3s ease';
                
                setTimeout(() => {
                    badge.style.opacity = '1';
                    badge.style.transform = 'scale(1)';
                }, 300);
            }

                            // Update expiry in account info section with countdown
                const accountExpiry = document.getElementById('account-expiry');

                if (accountExpiry) {
                    // Clear any existing countdown timer
                    if (window.expiryCountdownInterval) {
                        clearInterval(window.expiryCountdownInterval);
                        window.expiryCountdownInterval = null;
                    }

                    // Check if Lifetime
                    if (userAccountInfo.expiration_date === "Lifetime" ||
                        userAccountInfo.expiration_date === "Never" ||
                        userAccountInfo.expiration_date === "0" ||
                        userAccountInfo.expiration_date === 0) {
                        // Lifetime subscription - show status + Lifetime
                        accountExpiry.textContent = `${userAccountInfo.status} - Lifetime`;
                        accountExpiry.style.color = '#2ecc71'; // Green
                    } else if (isStandardPlan || !userAccountInfo.expiration_date || userAccountInfo.expiration_date === "Loading...") {
                        // Standard plan or no expiration data - just show status
                        accountExpiry.textContent = userAccountInfo.status;
                        accountExpiry.style.color = ''; // Reset color
                    } else {
                        // Parse the status_expires timestamp and start countdown
                        try {
                            let expiryDate;
                            if (userAccountInfo.status_expires) {
                                // Parse status_expires (YYYY-MM-DD HH:MM:SS format)
                                expiryDate = new Date(userAccountInfo.status_expires.replace(' ', 'T'));
                            } else if (typeof userAccountInfo.expiration_date === 'string') {
                                // Try different date formats
                                if (userAccountInfo.expiration_date.includes('/')) {
                                    // MM/DD/YYYY format
                                    const parts = userAccountInfo.expiration_date.split('/');
                                    expiryDate = new Date(parts[2], parts[0]-1, parts[1]);
                                } else if (userAccountInfo.expiration_date.includes('-')) {
                                    // YYYY-MM-DD format or YYYY-MM-DD HH:MM:SS format
                                    expiryDate = new Date(userAccountInfo.expiration_date.replace(' ', 'T'));
                                } else {
                                    // Try as timestamp
                                    expiryDate = new Date(parseInt(userAccountInfo.expiration_date));
                                }
                            } else if (typeof userAccountInfo.expiration_date === 'number') {
                                // Treat as timestamp
                                expiryDate = new Date(userAccountInfo.expiration_date);
                            }

                            // If we have a valid date, start countdown
                            if (expiryDate && !isNaN(expiryDate.getTime())) {
                                // Function to update countdown display
                                const updateCountdown = () => {
                                    const now = new Date();
                                    const diffMs = expiryDate - now;

                                    if (diffMs < 0) {
                                        // Expired
                                        accountExpiry.textContent = `${userAccountInfo.status} - Expired`;
                                        accountExpiry.style.color = '#e74c3c'; // Red
                                        if (window.expiryCountdownInterval) {
                                            clearInterval(window.expiryCountdownInterval);
                                        }
                                        return;
                                    }

                                    // Calculate time components
                                    const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                                    const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                                    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
                                    const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);

                                    // Format display
                                    let timeDisplay = '';
                                    let color = '';

                                    if (days > 0) {
                                        // Show days + hours
                                        timeDisplay = `${days}d ${hours}h`;
                                        if (days < 3) {
                                            color = '#e74c3c'; // Red
                                        } else if (days < 15) {
                                            color = '#f39c12'; // Yellow
                                        } else {
                                            color = '#2ecc71'; // Green
                                        }
                                    } else if (hours > 0) {
                                        // Show hours + minutes + seconds
                                        timeDisplay = `${hours}h ${minutes}m ${seconds}s`;
                                        color = '#e74c3c'; // Red
                                    } else {
                                        // Show minutes + seconds
                                        timeDisplay = `${minutes}m ${seconds}s`;
                                        color = '#e74c3c'; // Red
                                    }

                                    accountExpiry.textContent = `${userAccountInfo.status} - ${timeDisplay}`;
                                    accountExpiry.style.color = color;
                                };

                                // Initial update
                                updateCountdown();

                                // Start countdown timer (update every second)
                                window.expiryCountdownInterval = setInterval(updateCountdown, 1000);
                            } else {
                                // Fallback to just status
                                accountExpiry.textContent = userAccountInfo.status;
                                accountExpiry.style.color = ''; // Reset color
                            }
                        } catch (error) {
                            console.error('Error parsing expiry date:', error);
                            // Fallback to status
                            accountExpiry.textContent = userAccountInfo.status;
                            accountExpiry.style.color = ''; // Reset color
                        }
                    }
                }
        }
        
        function logout() {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('logout');
            }
        }

        // Steam Configuration Functions
        function selectSteamPath() {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('selectSteamPath');
            }
        }

        function updateSteamPathDisplay(path) {
            const pathElement = document.getElementById('selected-steam-path');
            if (pathElement) {
                if (path && path !== '') {
                    pathElement.textContent = path;
                    pathElement.style.color = 'var(--success)';
                } else {
                    // Show detected Steam path from Debug section
                    const detectedPath = document.getElementById('steam-path');
                    if (detectedPath && detectedPath.textContent !== 'Detecting...') {
                        pathElement.textContent = detectedPath.textContent;
                        pathElement.style.color = 'var(--text-secondary)';
                    } else {
                        pathElement.textContent = 'Detecting Steam path...';
                        pathElement.style.color = 'var(--text-secondary)';
                    }
                }
            }
        }

        function toggleExecutableDropdown() {
            const container = document.getElementById('executable-select-container');
            if (container) {
                container.classList.toggle('open');
            }
        }

        function selectExecutable(value, displayText) {
            const textElement = document.getElementById('selected-executable-text');
            const container = document.getElementById('executable-select-container');

            if (textElement) {
                textElement.textContent = displayText;
            }

            if (container) {
                container.classList.remove('open');
            }

            savePreferredExecutable(value);
        }

        function savePreferredExecutable(value) {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`savePreferredExecutable:${value}`);
            }
        }

        function openSteamPathPopup() {
            const popup = document.getElementById('steam-path-popup');
            const input = document.getElementById('steam-path-input');

            // Get current path from display
            const currentPath = document.getElementById('selected-steam-path');
            if (currentPath && currentPath.textContent !== 'Not set - using default') {
                input.value = currentPath.textContent;
            } else {
                input.value = '';
            }

            if (popup) {
                popup.style.display = 'flex';
            }
        }

        function closeSteamPathPopup() {
            const popup = document.getElementById('steam-path-popup');
            if (popup) {
                popup.style.display = 'none';
            }
        }

        function browseSteamPath() {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('selectSteamPath');
            }
            closeSteamPathPopup();
        }

        function saveSteamPathFromPopup() {
            const input = document.getElementById('steam-path-input');
            const path = input.value.trim();

            if (!path) {
                if (typeof showNotification === 'function') {
                    showNotification('Please enter a valid Steam path', 'error');
                }
                return;
            }

            // Send to backend for validation and saving
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`saveSteamPathManual:${path}`);
            }

            closeSteamPathPopup();
        }

        function openSteamConfigFile() {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('openSteamConfigFile');
            }
        }

        // Warning tooltip functions
        let warningTooltipVisible = false;

        function showWarningTooltip(event) {
            const tooltip = document.getElementById('warning-tooltip');
            if (!tooltip) return;

            warningTooltipVisible = true;
            updateWarningTooltipPosition(event);

            // Show tooltip with slight delay
            setTimeout(() => {
                if (warningTooltipVisible) {
                    tooltip.classList.add('show');
                }
            }, 100);
        }

        function updateWarningTooltipPosition(event) {
            const tooltip = document.getElementById('warning-tooltip');
            if (!tooltip || !warningTooltipVisible) return;

            const badge = event.currentTarget;
            const rect = badge.getBoundingClientRect();

            // Check if badge is visible on screen
            if (rect.top < 0 || rect.bottom > window.innerHeight || rect.left < 0 || rect.right > window.innerWidth) {
                // Badge is off screen, hide tooltip
                tooltip.classList.remove('show');
                return;
            }

            // Position tooltip below the badge, aligned to the right
            const tooltipY = rect.bottom + 10;
            const tooltipRight = window.innerWidth - rect.right;

            tooltip.style.right = tooltipRight + 'px';
            tooltip.style.top = tooltipY + 'px';
            tooltip.style.left = 'auto';
            tooltip.style.transform = 'none';

            // Make sure it's visible if it was hidden due to scroll
            if (warningTooltipVisible) {
                tooltip.classList.add('show');
            }
        }

        function hideWarningTooltip() {
            const tooltip = document.getElementById('warning-tooltip');
            if (!tooltip) return;

            warningTooltipVisible = false;
            tooltip.classList.remove('show');
        }

        // Hide tooltip on scroll
        document.addEventListener('scroll', function(event) {
            if (warningTooltipVisible) {
                const tooltip = document.getElementById('warning-tooltip');
                const badge = document.getElementById('warning-badge');

                if (tooltip && badge) {
                    const rect = badge.getBoundingClientRect();

                    // Check if badge is still visible
                    if (rect.top < 0 || rect.bottom > window.innerHeight || rect.left < 0 || rect.right > window.innerWidth) {
                        tooltip.classList.remove('show');
                    } else if (warningTooltipVisible) {
                        // Update position if still hovering
                        const tooltipY = rect.bottom + 10;
                        const tooltipRight = window.innerWidth - rect.right;
                        tooltip.style.right = tooltipRight + 'px';
                        tooltip.style.top = tooltipY + 'px';
                    }
                }
            }
        }, true); // Use capture phase to catch all scroll events

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const container = document.getElementById('executable-select-container');
            if (container && !container.contains(event.target)) {
                container.classList.remove('open');
            }
        });

        function loadSteamSettings(settings) {
            try {
                // Update Steam path display
                updateSteamPathDisplay(settings.steamPath || '');

                // Update preferred executable custom dropdown
                const execText = document.getElementById('selected-executable-text');
                if (execText && settings.preferredExecutable) {
                    if (settings.preferredExecutable === 'swav2.exe') {
                        execText.textContent = 'SWAv2';
                    } else if (settings.preferredExecutable === 'steam.exe') {
                        execText.textContent = 'Steam';
                    }
                }
            } catch (error) {
                console.error('Error loading Steam settings:', error);
            }
        }

        // Add event listener for search input to enable search-as-you-type
        window.addEventListener('load', function() {
            const searchInput = document.getElementById('game-search');
            if (searchInput) {
                searchInput.addEventListener('input', searchGames);
            }
        });
        
        function updateDebugGamesList(allFiles) {
            const allStFiles = document.getElementById('all-st-files');
            if (allStFiles) {
                if (allFiles && allFiles.length > 0) {
                    allStFiles.innerHTML = allFiles.join(', ');
                } else {
                    allStFiles.textContent = 'None found';
                }
            }
        }
        
        

        // Error Log Console Functions
        let errorLogUpdateInterval;
        
        // Initialize error console when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Check if we're on the settings page
            if (document.getElementById('error-console')) {
                refreshErrorLog();
                
                // Set up auto-refresh
                const autoRefreshToggle = document.getElementById('auto-refresh');
                if (autoRefreshToggle && autoRefreshToggle.checked) {
                    startAutoRefresh();
                }
                
                // Handle the toggle change
                if (autoRefreshToggle) {
                    autoRefreshToggle.addEventListener('change', function() {
                        if (this.checked) {
                            startAutoRefresh();
                        } else {
                            stopAutoRefresh();
                        }
                    });
                }
                
                // Prevent drag events when selecting text in the console
                const errorConsole = document.getElementById('error-console');
                if (errorConsole) {
                    errorConsole.addEventListener('mousedown', function(e) {
                        // Stop event propagation when clicking in the console
                        e.stopPropagation();
                    });
                    
                    // Prevent propagation of double-click events
                    errorConsole.addEventListener('dblclick', function(e) {
                        e.stopPropagation();
                    });
                    
                    // Add keyboard shortcut for copy (Ctrl+C)
                    errorConsole.addEventListener('keydown', function(e) {
                        // Enable Ctrl+C copy functionality
                        if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                            // Let the browser handle the copy action naturally
                            // This just ensures our other event preventions don't interfere
                        }
                        
                        // Stop propagation for all keyboard events in the console
                        e.stopPropagation();
                    });
                    
                    // Add context menu for copy operation
                    errorConsole.addEventListener('contextmenu', function(e) {
                        // Show a custom context menu with copy option
                        // For now, we'll just allow the default browser context menu
                        // by NOT preventing default. This gives a simple copy option.
                        e.stopPropagation();
                    });
                    
                    // Add a visual indicator that the console is selectable
                    errorConsole.title = "Text can be selected and copied (use Ctrl+C)";
                }
            }
        });
        
        function startAutoRefresh() {
            // Clear any existing interval
            stopAutoRefresh();
            
            // Refresh every 2 seconds
            errorLogUpdateInterval = setInterval(refreshErrorLog, 2000);
        }
        
        function stopAutoRefresh() {
            if (errorLogUpdateInterval) {
                clearInterval(errorLogUpdateInterval);
                errorLogUpdateInterval = null;
            }
        }
        
        function refreshErrorLog() {
            // Request the error log from C#
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('getErrorLog');
            }
        }
        
        function clearErrorConsole() {
            const console = document.getElementById('error-console');
            if (console) {
                console.textContent = 'Console cleared. Waiting for new logs...';
            }
            
            // Tell C# to clear the console (optional)
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('clearErrorLog');
            }
        }
        
        function updateErrorConsole(logData, useHtml = false) {
            const console = document.getElementById('error-console');
            if (console) {
                // Store selection information if there is any active selection
                let selectionStart = null;
                let selectionEnd = null;
                let hasSelection = false;
                
                if (document.activeElement === console && window.getSelection) {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        hasSelection = true;
                        // Try to store position information
                        try {
                            const range = selection.getRangeAt(0);
                            selectionStart = range.startOffset;
                            selectionEnd = range.endOffset;
                        } catch (e) {
                            // Selection storage failed, proceed without it
                            hasSelection = false;
                        }
                    }
                }
                
                // Update the content
                if (useHtml) {
                    // First replace literal '\n' sequences with '<br>'
                    let formattedContent = logData.replace(/\\n/g, '<br>');
                    
                    // Then replace actual newlines with '<br>'
                    formattedContent = formattedContent.replace(/\n/g, '<br>');
                    
                    console.innerHTML = formattedContent;
                } else {
                    console.textContent = logData;
                }
                
                // Auto-scroll to bottom only if we weren't selecting text
                if (!hasSelection) {
                    console.scrollTop = console.scrollHeight;
                }
                
                // If there was a selection, try to restore it
                if (hasSelection && selectionStart !== null && selectionEnd !== null) {
                    try {
                        const selection = window.getSelection();
                        const range = document.createRange();
                        
                        // Create a new range at the same position
                        if (console.firstChild) {
                            range.setStart(console.firstChild, Math.min(selectionStart, console.firstChild.length));
                            range.setEnd(console.firstChild, Math.min(selectionEnd, console.firstChild.length));
                            
                            // Apply the selection
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                    } catch (e) {
                        // Failed to restore selection, not critical
                        console.log('Failed to restore selection:', e);
                    }
                }
            }
        }

        // ... existing code ...

        // Function to toggle section collapse/expand
        function toggleSection(section) {
            section.classList.toggle('collapsed');
        }

        // Function to render patch notes from API data
        function renderPatchNotes(data, targetElementId = 'patch-notes-container') {
            const container = document.getElementById(targetElementId);
            if (!container) return;
            
            // Set container class based on note type
            container.className = 'patch-notes type-' + (data.type || 'patch');
            
            // Get type label and icon
            const typeInfo = getNoteTypeInfo(data.type || 'patch');
            
            // Format the date
            const releaseDate = new Date(data.date);
            const formattedDate = releaseDate.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            
            // Create HTML content
            let html = `
                <div class="patch-notes-header">
                    <div class="patch-notes-title">
                        <i class="${typeInfo.icon}"></i>
                        <span>${data.title}</span>
                        <span class="type-indicator ${data.type || 'patch'}">${typeInfo.label}</span>
                    </div>
                    <div class="patch-notes-version">${data.version ? 'v' + data.version : ''}</div>
                </div>
                <div class="patch-notes-content">
            `;
            
            // Add highlights section if provided and not empty
            if (data.highlights && Array.isArray(data.highlights) && data.highlights.length > 0) {
                // Filter out empty items
                const validHighlights = data.highlights.filter(item => item && item.trim());
                
                if (validHighlights.length > 0) {
                    html += `
                        <div class="patch-notes-section highlights">
                            <div class="patch-notes-section-header" onclick="toggleSection(this.parentNode)">
                                <div class="patch-notes-section-title">
                                    <i class="fas fa-star"></i>
                                    <span>Highlights</span>
                                    <i class="fas fa-chevron-down section-toggle"></i>
                                </div>
                            </div>
                            <div class="patch-notes-list-container">
                                <ul class="patch-notes-list">
                `;
                    
                    validHighlights.forEach(highlight => {
                        html += `<li class="patch-notes-item highlight">${highlight}</li>`;
                    });
                    
                    html += `
                                </ul>
                            </div>
                        </div>
                    `;
                }
            }
            
            // Add changes sections if this is a patch type
            if (data.changes) {
                // Added features - only if there are items
                if (data.changes.added && Array.isArray(data.changes.added) && data.changes.added.length > 0) {
                    // Filter out any empty items
                    const addedItems = data.changes.added.filter(item => item && item.trim());
                    
                    // Only add the section if there are non-empty items
                    if (addedItems.length > 0) {
                        html += `
                            <div class="patch-notes-section features">
                                <div class="patch-notes-section-header" onclick="toggleSection(this.parentNode)">
                                    <div class="patch-notes-section-title">
                                        <i class="fas fa-plus-circle"></i>
                                        <span>Added</span>
                                        <i class="fas fa-chevron-down section-toggle"></i>
                                    </div>
                                </div>
                                <div class="patch-notes-list-container">
                                    <ul class="patch-notes-list">
                `;
                        
                        addedItems.forEach(item => {
                            html += `<li class="patch-notes-item">${item}</li>`;
                        });
                        
                        html += `
                                    </ul>
                                </div>
                            </div>
                        `;
                    }
                }
                
                // Fixed bugs - only if there are items
                if (data.changes.fixed && Array.isArray(data.changes.fixed) && data.changes.fixed.length > 0) {
                    // Filter out any empty items
                    const fixedItems = data.changes.fixed.filter(item => item && item.trim());
                    
                    // Only add the section if there are non-empty items
                    if (fixedItems.length > 0) {
                        html += `
                            <div class="patch-notes-section fixes">
                                <div class="patch-notes-section-header" onclick="toggleSection(this.parentNode)">
                                    <div class="patch-notes-section-title">
                                        <i class="fas fa-wrench"></i>
                                        <span>Fixed</span>
                                        <i class="fas fa-chevron-down section-toggle"></i>
                                    </div>
                                </div>
                                <div class="patch-notes-list-container">
                                    <ul class="patch-notes-list">
                `;
                        
                        fixedItems.forEach(item => {
                            html += `<li class="patch-notes-item">${item}</li>`;
                        });
                        
                        html += `
                                    </ul>
                                </div>
                            </div>
                        `;
                    }
                }
                
                // Removed features - only if there are items
                if (data.changes.removed && Array.isArray(data.changes.removed) && data.changes.removed.length > 0) {
                    // Filter out any empty items
                    const removedItems = data.changes.removed.filter(item => item && item.trim());
                    
                    // Only add the section if there are non-empty items
                    if (removedItems.length > 0) {
                        html += `
                            <div class="patch-notes-section removed">
                                <div class="patch-notes-section-header" onclick="toggleSection(this.parentNode)">
                                    <div class="patch-notes-section-title">
                                        <i class="fas fa-minus-circle"></i>
                                        <span>Removed</span>
                                        <i class="fas fa-chevron-down section-toggle"></i>
                                    </div>
                                </div>
                                <div class="patch-notes-list-container">
                                    <ul class="patch-notes-list">
                `;
                        
                        removedItems.forEach(item => {
                            html += `<li class="patch-notes-item">${item}</li>`;
                        });
                        
                        html += `
                                    </ul>
                                </div>
                            </div>
                        `;
                    }
                }
            }
            
            // For non-patch types like notifications, alerts, etc., show the message only if it exists
            if (data.message && data.message.trim()) {
                html += `
                    <div class="patch-notes-message">
                        ${data.message}
                    </div>
                `;
            }
            
            // Add comment if provided and not empty
            if (data.comment && data.comment.trim()) {
                html += `
                    <div class="patch-notes-comment">
                        <div class="comment-content">${data.comment.replace(/\n/g, '<br>')}</div>
                    </div>
                `;
            }
            
            // Add internal comments section (only visible to admins) if there are comments
            if (data.internal_comments && Array.isArray(data.internal_comments) && data.internal_comments.length > 0) {
                // Filter out any empty comments
                const validComments = data.internal_comments.filter(comment => comment && comment.trim());
                
                if (validComments.length > 0) {
                    html += `
                        <div class="internal-comments-section" id="${targetElementId}-internal-comments">
                            <div class="internal-comments-header">
                                <i class="fas fa-lock"></i>
                                <span>Internal Comments (Admin Only)</span>
                            </div>
                            <ul class="internal-comments-list">
                `;
                    
                    validComments.forEach(comment => {
                        html += `<li class="internal-comment-item">${comment}</li>`;
                    });
                    
                    html += `
                            </ul>
                        </div>
                    `;
                }
            }
            
            // Add release date
            html += `
                <div class="patch-date">
                    ${formattedDate}
                </div>
            `;
            
            html += `</div>`; // Close patch-notes-content
            
            // Set the HTML content
            container.innerHTML = html;
            
            // Expand the highlights section by default
            const highlightsSection = container.querySelector('.patch-notes-section.highlights');
            if (highlightsSection) {
                // Make sure it's expanded
                highlightsSection.classList.remove('collapsed');
            }
            
            // Show internal comments only for admin users
            showInternalCommentsIfAdmin(targetElementId);
        }

        // Function to show internal comments for admin users
        function showInternalCommentsIfAdmin(targetElementId = 'patch-notes-container') {
            const internalCommentsSection = document.getElementById(`${targetElementId}-internal-comments`);
            if (!internalCommentsSection) return;
            
            // Check if user is admin
            const isAdmin = userAccountInfo.status.toLowerCase().includes('admin');
            
            // Show/hide internal comments based on user status
            internalCommentsSection.style.display = isAdmin ? 'block' : 'none';
        }

        // Helper function to get note type info (icon and label)
        function getNoteTypeInfo(type) {
            const types = {
                'patch': { icon: 'fas fa-code-branch', label: 'PATCH' },
                'notification': { icon: 'fas fa-bell', label: 'NOTICE' },
                'alert': { icon: 'fas fa-exclamation-triangle', label: 'ALERT' },
                'warning': { icon: 'fas fa-exclamation-circle', label: 'WARNING' },
                'info': { icon: 'fas fa-info-circle', label: 'INFO' },
                'maintenance': { icon: 'fas fa-tools', label: 'MAINTENANCE' }
            };
            
            return types[type] || types['patch'];
        }

        // Function to fetch patch notes from the API
        function fetchPatchNotes() {
            // Show loading state
            const container = document.getElementById('patch-notes-container');
            if (container) {
                container.innerHTML = `
                    <div class="patch-notes-header">
                        <div class="patch-notes-title">
                            <i class="fas fa-sync fa-spin"></i>
                            <span>Loading patch notes...</span>
                        </div>
                    </div>
                `;
            }
            
            // Request patch notes data from backend using WebView message
            if (window.chrome && window.chrome.webview) {
                // Send message to request patch notes
                window.chrome.webview.postMessage('getPatchNotes');
                
                // The response will be handled by the message event listener
                console.log('Requested patch notes from the backend');
            } else {
                // Fallback for browser testing - show error message
                console.error('WebView not available');
                if (container) {
                    container.innerHTML = `
                        <div class="patch-notes-header">
                            <div class="patch-notes-title">
                                <i class="fas fa-exclamation-circle"></i>
                                <span>Could not load patch notes</span>
                            </div>
                        </div>
                        <div class="patch-notes-message">
                            Unable to connect to the server. Please try again later.
                        </div>
                    `;
                }
            }
        }

        // Function to render multiple patch notes
        function renderMultiplePatchNotes(notesArray) {
            if (!notesArray || !notesArray.length) return;

            const container = document.getElementById('patch-notes-container');
            if (!container) {
                console.warn('Patch notes container not found, skipping render');
                return;
            }

            const parentContainer = container.parentElement;
            if (!parentContainer) {
                console.warn('Patch notes parent container not found, skipping render');
                return;
            }

            // Clear the container
            parentContainer.innerHTML = '<h2>SWA V2 Updates</h2>';

            // Sort notes by date, most recent first
            notesArray.sort((a, b) => {
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);
                return dateB - dateA; // Most recent first
            });

            // Create a container for each note
            notesArray.forEach((noteData, index) => {
                const noteElement = document.createElement('div');
                noteElement.id = `patch-notes-${index}`;
                noteElement.className = 'patch-notes type-' + (noteData.type || 'patch');
                noteElement.style.marginBottom = '20px';
                parentContainer.appendChild(noteElement);

                // Render each note
                renderPatchNotes(noteData, noteElement.id);
            });
        }

        // Function to show notification when no update is available
        function showNoUpdateNotification(version) {
            // Update text in notification
            const currentVersionEl = document.getElementById('current-version-popup');
            const newVersionEl = document.getElementById('new-version-popup');
            
            if (currentVersionEl) currentVersionEl.textContent = version;
            if (newVersionEl) newVersionEl.textContent = version;
            
            const descriptionEl = document.querySelector('#update-notification .update-title');
            if (descriptionEl) descriptionEl.textContent = 'Your installation of SWA V2 is up to date.';
            
            // Update version container styling
            const versionItemOutdated = document.querySelector('#update-notification .version-item.outdated');
            if (versionItemOutdated) {
                versionItemOutdated.classList.remove('outdated');
                versionItemOutdated.querySelector('i').className = 'fas fa-check-circle';
                versionItemOutdated.querySelector('i').style.color = '#4CAF50';
                const span = versionItemOutdated.querySelector('span');
                if (span) {
                    span.style.textDecoration = 'none';
                    span.style.color = 'var(--text)';
                }
            }
            
            // Update message about up to date
            const updateDescriptionEl = document.querySelector('#update-notification .update-description');
            if (updateDescriptionEl) updateDescriptionEl.textContent = 'No action is required. You will be notified when a new version is available.';
            
            // Replace update button with close button
            const footerEl = document.querySelector('#update-notification .popup-footer');
            if (footerEl) {
                footerEl.innerHTML = `
                    <button class="secondary-btn" onclick="hideUpdateNotification()" style="height: 42px; display: inline-flex; align-items: center; background: rgba(40, 40, 40, 0.8); color: var(--text); border: none; border-radius: 6px; padding: 0 30px; min-width: 120px; cursor: pointer; font-weight: 500; transition: all 0.2s ease;">
                        <i class="fas fa-times" style="margin-right: 10px; font-size: 16px;"></i> Close
                    </button>
                `;
            }
            
            // Show notification popup
            const notification = document.getElementById('update-notification');
            if (notification) {
                notification.style.display = 'flex';
            }
        }

        // Add direct "Check for Updates" button handler
        document.addEventListener('DOMContentLoaded', function() {
            const checkUpdatesBtn = document.getElementById('check-updates-btn');
            if (checkUpdatesBtn) {
                // Replace the inline handler with a direct one
                checkUpdatesBtn.removeAttribute('onclick');
                checkUpdatesBtn.addEventListener('click', function() {
                    checkForUpdates(true);
                });
            }
        });

        // Function to update log message in title bar
        function updateLogMessage(message, type = '') {
            const logElement = document.getElementById('log-message');
            if (!logElement) return;
            
            // Clear any existing classes
            logElement.className = 'log-message';
            
            // Add type class if provided
            if (type) {
                logElement.classList.add(type);
            }
            
            // Set the message text
            logElement.textContent = message;
            
            // Ensure visibility
            logElement.style.opacity = '1';
            
            // Auto-hide after 10 seconds unless it's a welcome message
            if (!message.includes('Welcome')) {
                setTimeout(() => {
                    logElement.style.opacity = '0.3';
                }, 10000);
            }
        }

        function startRateLimitCountdown(waitTimeSeconds) {
            let remainingTime = waitTimeSeconds;
            
            // Disable only the add game buttons (not scan games button)
            const plusButton = document.querySelector('button[onclick="showAddGamePopup()"]');
            const addGameButtonInPopup = document.querySelector('button[onclick="addNewGame()"]');
            
            // Set global rate limit flag
            window.rateLimitActive = true;
            
            // Disable the plus button (show add game popup)
            if (plusButton) {
                plusButton.disabled = true;
                plusButton.style.opacity = '0.5';
                plusButton.style.cursor = 'not-allowed';
            }
            
            // Disable the add game button in the popup
            if (addGameButtonInPopup) {
                addGameButtonInPopup.disabled = true;
                addGameButtonInPopup.style.opacity = '0.5';
                addGameButtonInPopup.style.cursor = 'not-allowed';
            }
            
            // Update countdown every second
            const countdownInterval = setInterval(() => {
                if (remainingTime > 0) {
                    updateLogMessage(`Please wait ${remainingTime} seconds before adding another game (guest limit)`, 'warning');
                    remainingTime--;
                } else {
                    // Countdown finished
                    clearInterval(countdownInterval);
                    updateLogMessage('You can now add another game', 'success');
                    
                    // Clear global rate limit flag
                    window.rateLimitActive = false;
                    
                    // Re-enable the plus button
                    if (plusButton) {
                        plusButton.disabled = false;
                        plusButton.style.opacity = '1';
                        plusButton.style.cursor = 'pointer';
                    }
                    
                    // Re-enable the add game button in the popup
                    if (addGameButtonInPopup) {
                        addGameButtonInPopup.disabled = false;
                        addGameButtonInPopup.style.opacity = '1';
                        addGameButtonInPopup.style.cursor = 'pointer';
                    }
                }
            }, 1000);
            
            // Initial message
            updateLogMessage(`Please wait ${remainingTime} seconds before adding another game (guest limit)`, 'warning');
        }

        function restartSteam() {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('restartSteam');
            } else {
                alert('Restart Steam is only available in the desktop app.');
            }
        }

        function restartSteamAndApp() {
            const restartBtn = document.getElementById('restart-steam-btn');
            if (restartBtn && restartBtn.classList.contains('disabled')) {
                // Button is disabled, do nothing (tooltip will show on hover)
                return;
            }

            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('restartSteamAndApp');
            } else {
                alert('Restart is only available in the desktop app.');
            }
        }
        
        function patchSteam() {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('patchSteam');
            }
        }

        // Function for toggling action menu with event object
        function toggleActionMenu(event, menuId) {
            event.stopPropagation();
            event.preventDefault();
            
            const menu = document.getElementById(menuId);
            if (!menu) return;
            
            // Check if this menu is already open
            const isThisMenuOpen = menu.classList.contains('show');
            
            // Close all other open menus first
            closeAllMenus();
            
            // If this menu was already open, we're done (closeAllMenus already closed it)
            if (isThisMenuOpen) {
                currentOpenMenuId = null;
                return;
            }
            
            // Open this menu
            menu.classList.add('show');
            currentOpenMenuId = menuId;
            
            // Position the menu
            const button = event.currentTarget;
            const buttonRect = button.getBoundingClientRect();
            
            // Reset any previous positioning
            menu.style.top = '';
            menu.style.bottom = '';
            menu.style.left = '';
            menu.style.right = '';
            
            // Move to end of body for proper z-index
            document.body.appendChild(menu);
            
            // Force a reflow to get accurate measurements
            void menu.offsetWidth;
            
            // Get dimensions after appending to body
            const menuRect = menu.getBoundingClientRect();
            
            // Position menu to the right of the button
            menu.style.top = `${buttonRect.top + buttonRect.height + 5}px`;
            menu.style.right = `${document.documentElement.clientWidth - buttonRect.right}px`;
            
            // Add a click outside listener to close the menu
            setTimeout(() => {
                document.addEventListener('click', closeMenuOnClickOutside);
            }, 10);
        }
        
        // Function to update game with latest version
        function updateGame(gameId) {
            console.log(`Updating game: ${gameId}`);
            
            // Close menus if open
            closeAllMenus();
            
            // Show update in progress
            const updateBtn = document.querySelector(`.game-card[data-id="${gameId}"] .update-btn`);
            if (updateBtn) {
                updateBtn.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i>';
                updateBtn.disabled = true;
            }
            
            // Add loading indicator to game meta tags
            const metaTags = document.getElementById(`game-meta-${gameId}`);
            if (metaTags) {
                metaTags.innerHTML = '<div class="meta-tag loading">Updating game...</div>';
            }
            
            // Clear the cache for this game
            if (gameDetailsCache[gameId]) {
                delete gameDetailsCache[gameId];
            }
            
            // Send message to backend to update the game
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`updateGame:${gameId}`);
                
                // This would trigger a re-scan which will refresh the game data
                // For now, let's just fetch the latest data after a short delay
                setTimeout(() => {
                    fetchGameDetails(gameId);
                    
                    // Re-enable update button
                    if (updateBtn) {
                        updateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                        updateBtn.disabled = false;
                        updateBtn.style.display = 'none'; // Hide the button after update
                    }
                }, 1500);
            }
        }

        // Function to add a show image button to the game card
        function addShowImageButton(gameCard, gameId, gameData) {
            if (!gameData.image) return;
            
            // Check if button already exists
            if (gameCard.querySelector('.show-image-btn')) return;
            
            // Create the action buttons container if it doesn't exist
            let actionButtons = gameCard.querySelector('.action-buttons');
            if (!actionButtons) {
                actionButtons = document.createElement('div');
                actionButtons.className = 'action-buttons';
                
                // Find where to insert it (after game-meta-tags)
                const metaTagsElement = gameCard.querySelector('.game-meta-tags');
                if (metaTagsElement) {
                    metaTagsElement.after(actionButtons);
                } else {
                    const infoCol = gameCard.querySelector('.game-info-col');
                    if (infoCol) {
                        infoCol.appendChild(actionButtons);
                    }
                }
            }
            
            // Create and add the button
            const showImageBtn = document.createElement('button');
            showImageBtn.className = 'show-image-btn';
            showImageBtn.innerHTML = '<i class="fas fa-image"></i> View Image';
            showImageBtn.onclick = function() {
                showImageModal(gameId, gameData.name, gameData.image);
            };
            
            actionButtons.appendChild(showImageBtn);
        }

        // Function to show the image modal
        function showImageModal(gameId, gameName, imageUrl) {
            const modal = document.getElementById('image-modal');
            const modalTitle = modal.querySelector('.image-modal-title');
            const modalImage = document.getElementById('modal-image');
            const modalLoading = modal.querySelector('.image-modal-loading');
            const modalError = modal.querySelector('.image-modal-error');
            
            // Set title
            modalTitle.textContent = gameName || `Game ${gameId}`;
            
            // Reset modal state
            modalImage.style.display = 'none';
            modalLoading.style.display = 'block';
            modalError.style.display = 'none';
            
            // Show modal
            modal.classList.add('active');
            
            // Load image
            const img = new Image();
            img.onload = function() {
                modalLoading.style.display = 'none';
                modalImage.src = imageUrl;
                modalImage.style.display = 'block';
            };
            img.onerror = function() {
                modalLoading.style.display = 'none';
                modalError.style.display = 'block';
                modalError.textContent = `Failed to load image for ${gameName || 'Game ' + gameId}`;
            };
            img.src = imageUrl;
            
            // Add event listener to close on escape key
            document.addEventListener('keydown', closeModalOnEscape);
            
            // Add event listener to close on click outside
            modal.addEventListener('click', function(event) {
                if (event.target === modal) {
                    closeImageModal();
                }
            });
        }

        // Function to close the image modal
        function closeImageModal() {
            const modal = document.getElementById('image-modal');
            modal.classList.remove('active');
            
            // Remove event listeners
            document.removeEventListener('keydown', closeModalOnEscape);
        }

        // Function to close modal on escape key
        function closeModalOnEscape(e) {
            if (e.key === 'Escape') {
                closeImageModal();
            }
        }

        // Function to close all menus
        function closeAllMenus() {
            document.querySelectorAll('.action-menu.show').forEach(menu => {
                menu.classList.remove('show');
            });
            document.removeEventListener('click', closeMenuOnClickOutside);
            currentOpenMenuId = null;
        }

        // Function to check if game needs update and show button
        function checkAndShowUpdateButton() {
            // Process all game cards
            document.querySelectorAll('.game-card').forEach(gameCard => {
                const gameId = gameCard.dataset.id;
                if (!gameId) return;
                
                const updateBtn = gameCard.querySelector('.update-action-btn');
                if (!updateBtn) return;
                
                // Get data for comparison
                const localLastUpdate = window.gameDataMap && window.gameDataMap[gameId] ? 
                    window.gameDataMap[gameId].lastUpdate : '';
                const apiLastUpdate = gameDetailsCache[gameId]?.last_update;
                
                // Show update button if:
                // 1. No local update date exists, OR 
                // 2. The local update date doesn't match the API update date
                const showUpdateBtn = !localLastUpdate || (apiLastUpdate && localLastUpdate !== apiLastUpdate);
                updateBtn.style.display = showUpdateBtn ? "flex" : "none";
                
                if (showUpdateBtn) {
                    console.log(`Showing update button for game ${gameId}: ${!localLastUpdate ? 'No local update date' : 'Update date mismatch'}`);
                }
            });
        }

        // Handle image loading errors (prevent infinite retry loop)
        function handleImageError(img) {
            // Check if we already tried to load a fallback
            if (img.dataset.errorHandled) {
                // Already tried fallback, just hide the image
                img.style.display = 'none';
                return;
            }

            // Mark as handled and remove onerror to prevent infinite loop
            img.dataset.errorHandled = 'true';
            img.onerror = null;

            // Try a simple gray box as fallback (data URI, no network request)
            img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="115" height="43"%3E%3Crect fill="%231a1a1a" width="115" height="43"/%3E%3Ctext x="50%25" y="50%25" text-anchor="middle" dy=".3em" fill="%23666" font-family="Arial" font-size="12"%3EGame%3C/text%3E%3C/svg%3E';
        }

        // DLC Functions
        function toggleDLCCard(headerElement) {
            const card = headerElement.closest('.dlc-card');
            const list = card.querySelector('.dlc-list');
            
            // Close any open menus when toggling
            closeAllDLCMenus();
            
            // Toggle expanded state with smooth animation
            if (card.classList.contains('expanded')) {
                // Collapsing
                card.classList.remove('expanded');
            } else {
                // Expanding
                card.classList.add('expanded');
            }
        }

        // DLC Action Menu Functions - using games page approach
        function toggleDLCActionMenu(event, menuId) {
            event.stopPropagation();
            event.preventDefault();
            
            const menu = document.getElementById(menuId);
            if (!menu) return;
            
            // Check if this menu is already open
            const isThisMenuOpen = menu.classList.contains('show');
            
            // Close all other open menus first
            closeAllDLCMenus();
            
            // If this menu was already open, we're done (closeAllDLCMenus already closed it)
            if (isThisMenuOpen) {
                return;
            }
            
            // Open this menu
            menu.classList.add('show');
            
            // Position the menu
            const button = event.currentTarget;
            const buttonRect = button.getBoundingClientRect();
            
            // Reset any previous positioning
            menu.style.top = '';
            menu.style.bottom = '';
            menu.style.left = '';
            menu.style.right = '';
            menu.style.position = 'fixed';
            menu.style.zIndex = '9999';
            
            // Position to the left of the button (next to it) for DLC Manager
            menu.style.top = `${buttonRect.top -30}px`;
            menu.style.right = `${document.documentElement.clientWidth - buttonRect.left}px`;
            
            // Add a click outside listener to close the menu
            setTimeout(() => {
                document.addEventListener('click', closeMenuOnClickOutside);
            }, 10);
        }

        function closeMenuOnClickOutside(e) {
            if (!e.target.closest('.action-menu') && !e.target.closest('.dlc-item-menu') && 
                !e.target.closest('.action-toggle') && !e.target.closest('.dlc-action-btn')) {
                closeAllDLCMenus();
            }
        }
        
        function closeDLCActionMenu() {
            const menus = document.querySelectorAll('.action-menu');
            menus.forEach(menu => {
                menu.classList.remove('show');
            });
            document.removeEventListener('click', closeMenuOnClickOutside);
        }

        // DLC Item Menu Functions
        function toggleDLCItemMenu(event, menuId) {
            event.stopPropagation();
            event.preventDefault();
            
            const menu = document.getElementById(menuId);
            if (!menu) return;
            
            // Check if this menu is already open
            const isThisMenuOpen = menu.classList.contains('show');
            
            // Close all other open menus first
            closeAllDLCMenus();
            
            // If this menu was already open, we're done (closeAllDLCMenus already closed it)
            if (isThisMenuOpen) {
                return;
            }
            
            // Open this menu
            menu.classList.add('show');
            
            // Position the menu
            const button = event.currentTarget;
            const buttonRect = button.getBoundingClientRect();
            
            // Reset any previous positioning
            menu.style.top = '';
            menu.style.bottom = '';
            menu.style.left = '';
            menu.style.right = '';
            menu.style.position = 'fixed';
            menu.style.zIndex = '9999';
            
            // Position to the left of the button (next to it) for DLC Manager
            menu.style.top = `${buttonRect.top - 30}px`;
            menu.style.right = `${document.documentElement.clientWidth - buttonRect.left}px`;
            
            // Add a click outside listener to close the menu
            setTimeout(() => {
                document.addEventListener('click', closeMenuOnClickOutside);
            }, 10);
        }

        function closeDLCItemMenu() {
            const menus = document.querySelectorAll('.dlc-item-menu');
            menus.forEach(menu => {
                menu.classList.remove('show');
            });
            document.removeEventListener('click', closeMenuOnClickOutside);
        }

        // Close all DLC menus
        function closeAllDLCMenus() {
            const allMenus = document.querySelectorAll('.action-menu, .dlc-item-menu');
            allMenus.forEach(menu => {
                menu.classList.remove('show');
            });
            document.removeEventListener('click', closeMenuOnClickOutside);
        }

        // DLC Management Functions
        function removeDLC(dlcId) {
            if (confirm(`Are you sure you want to remove DLC ${dlcId}?`)) {
                console.log(`Removing DLC: ${dlcId}`);
                
                // Find and remove the DLC item from the DOM
                const dlcItem = document.querySelector(`[data-dlc-id="${dlcId}"]`);
                if (dlcItem) {
                    dlcItem.style.animation = 'fadeOut 0.3s ease';
                    setTimeout(() => {
                        dlcItem.remove();
                        updateDLCCount();
                    }, 300);
                }
                
                // This would typically make an API call to the C# backend
                // window.chrome.webview.postMessage({
                //     type: 'removeDLC',
                //     dlcId: dlcId
                // });
            }
        }

        function disableDLC(dlcId) {
            console.log(`Disabling DLC: ${dlcId}`);
            
            // Find the DLC item and update the menu item text
            const dlcItem = document.querySelector(`[data-dlc-id="${dlcId}"]`);
            if (dlcItem) {
                const menuItem = dlcItem.querySelector('.action-item:nth-child(2)');
                if (menuItem) {
                    menuItem.innerHTML = '<span>Enable DLC</span><i class="fas fa-toggle-on"></i>';
                    menuItem.setAttribute('onclick', `enableDLC('${dlcId}'); closeDLCItemMenu();`);
                }
            }
            
            // This would typically make an API call to the C# backend
            // window.chrome.webview.postMessage({
            //     type: 'disableDLC',
            //     dlcId: dlcId
            // });
        }

        function enableDLC(dlcId) {
            console.log(`Enabling DLC: ${dlcId}`);
            
            // Find the DLC item and update the menu item text
            const dlcItem = document.querySelector(`[data-dlc-id="${dlcId}"]`);
            if (dlcItem) {
                const menuItem = dlcItem.querySelector('.action-item:nth-child(2)');
                if (menuItem) {
                    menuItem.innerHTML = '<span>Disable DLC</span><i class="fas fa-toggle-off"></i>';
                    menuItem.setAttribute('onclick', `disableDLC('${dlcId}'); closeDLCItemMenu();`);
                }
            }
            
            // This would typically make an API call to the C# backend
            // window.chrome.webview.postMessage({
            //     type: 'enableDLC',
            //     dlcId: dlcId
            // });
        }

        // DLC Card Management Functions


        function removeAllDLCs(gameId) {
            showDLCRemovalDialog(gameId);
        }
        
        function showDLCRemovalDialog(gameId) {
            // Get game name if available
            let gameName = gameId;
            const gameElement = document.querySelector(`[data-game-id="${gameId}"]`);
            if (gameElement) {
                const gameNameElement = gameElement.querySelector('.game-name');
                if (gameNameElement) {
                    gameName = gameNameElement.textContent;
                }
            }
            
            // Create dialog container if it doesn't exist
            let dialogContainer = document.getElementById('dlc-removal-dialog');
            if (!dialogContainer) {
                dialogContainer = document.createElement('div');
                dialogContainer.id = 'dlc-removal-dialog';
                dialogContainer.style.position = 'fixed';
                dialogContainer.style.top = '0';
                dialogContainer.style.left = '0';
                dialogContainer.style.width = '100%';
                dialogContainer.style.height = '100%';
                dialogContainer.style.backgroundColor = 'rgba(0,0,0,0.7)';
                dialogContainer.style.display = 'flex';
                dialogContainer.style.alignItems = 'center';
                dialogContainer.style.justifyContent = 'center';
                dialogContainer.style.zIndex = '9999';
                document.body.appendChild(dialogContainer);
            } else {
                dialogContainer.style.display = 'flex';
            }
            
            // Set dialog content
            dialogContainer.innerHTML = `
                <div style="background-color: #1a1a1a; border-radius: 5px; width: 400px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                    <div style="display: flex; justify-content: space-between; padding: 15px 20px; border-bottom: 1px solid #333;">
                        <h3 style="margin: 0; color: #fff; font-size: 18px;">Remove DLCs</h3>
                        <span style="cursor: pointer; color: #888; font-size: 18px;" onclick="hideDLCRemovalDialog()"></span>
                    </div>
                    <div style="padding: 20px; border-bottom: 1px solid #333;">
                        <div style="display: flex; align-items: center; background-color: rgba(255, 153, 0, 0.1); padding: 15px; border-radius: 5px; border: 1px solid rgba(255, 153, 0, 0.3);">
                            <i class="fas fa-exclamation-triangle" style="color: #ff9900; font-size: 24px; margin-right: 15px;"></i>
                            <div style="color: #fff;">
                                Are you sure you want to remove ALL DLCs for ${gameName}? This action cannot be undone.
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: flex-end; padding: 15px 20px;">
                        <button style="background-color: #333; border: none; color: #fff; padding: 8px 20px; border-radius: 4px; margin-right: 10px; cursor: pointer;" onclick="hideDLCRemovalDialog()">Cancel</button>
                        <button style="background-color: #a92e2e; border: none; color: #fff; padding: 8px 20px; border-radius: 4px; cursor: pointer; display: flex; align-items: center;" onclick="removeDLCsConfirmed('${gameId}')">
                            <i class="fas fa-trash" style="margin-right: 8px;"></i> Remove
                        </button>
                    </div>
                </div>
            `;
            
            // Close dialog on ESC key
            document.addEventListener('keydown', closeDLCDialogOnEsc);
        }
        
        function hideDLCRemovalDialog() {
            const dialogContainer = document.getElementById('dlc-removal-dialog');
            if (dialogContainer) {
                dialogContainer.style.display = 'none';
            }
            document.removeEventListener('keydown', closeDLCDialogOnEsc);
        }
        
        function closeDLCDialogOnEsc(e) {
            if (e.key === 'Escape') {
                hideDLCRemovalDialog();
            }
        }
        
        function removeDLCsConfirmed(gameId) {
            console.log(`Removing all DLCs for game: ${gameId}`);
            
            // Hide the dialog
            hideDLCRemovalDialog();
            
            // Show loading state for the card
            const card = document.querySelector(`[data-game-id="${gameId}"]`);
            if (card) {
                const dlcList = card.querySelector('.dlc-list');
                if (dlcList) {
                    dlcList.innerHTML = `
                        <div class="loading-state" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100px; color: var(--text-secondary); text-align: center; padding: 20px;">
                            <i class="fas fa-sync-alt fa-spin" style="font-size: 24px; margin-bottom: 16px;"></i>
                            <p style="font-size: 14px; margin: 0;">Removing DLCs for this game...</p>
                        </div>
                    `;
                }
            }
            
            // Call the C# backend to remove all DLCs for this specific game
            if (window.chrome && window.chrome.webview) {
                // This uses our new message format "dlcs:removeAllForGame:{gameId}"
                window.chrome.webview.postMessage(`dlcs:removeAllForGame:${gameId}`);
                
                // The C# backend will refresh the DLC manager after removal
                updateLogMessage('DLC removed', 'success');
            } else {
                console.error('WebView2 communication not available');
                updateLogMessage('Error: WebView communication not available', 'error');
            }
        }

        // Helper Functions
        function updateDLCCount() {
            const cards = document.querySelectorAll('.dlc-card');
            let totalDLCs = 0;
            
            cards.forEach(card => {
                const dlcItems = card.querySelectorAll('.dlc-item');
                const countElement = card.querySelector('.dlc-count');
                if (countElement) {
                    const count = dlcItems.length;
                    countElement.textContent = `${count} DLC${count !== 1 ? 's' : ''}`;
                    totalDLCs += count;
                }
            });
            
            // Update the DLCs summary
            const dlcsSummary = document.getElementById('dlcs-summary');
            if (dlcsSummary) {
                dlcsSummary.classList.remove('no-dlcs');
                if (totalDLCs > 0) {
                    dlcsSummary.innerHTML = `<i class="fas fa-puzzle-piece"></i> Found ${totalDLCs} DLC${totalDLCs === 1 ? '' : 's'}`;
                } else {
                    dlcsSummary.innerHTML = '<i class="fas fa-exclamation-circle"></i> No DLCs found';
                    dlcsSummary.classList.add('no-dlcs');
                }
            }
        }

        function searchDLCs() {
            const searchInput = document.getElementById('dlc-search');
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.trim().toLowerCase();
            const cards = document.querySelectorAll('.dlc-card');
            let visibleCount = 0;
            
            cards.forEach(card => {
                const gameName = card.querySelector('.game-name')?.textContent.toLowerCase() || '';
                const gameId = card.querySelector('.game-id')?.textContent.toLowerCase() || '';
                const dlcItems = card.querySelectorAll('.dlc-item');
                
                // Check if game name or ID matches
                const gameMatches = gameName.includes(searchTerm) || gameId.includes(searchTerm);
                
                // Check if any DLC name matches
                let dlcMatches = false;
                dlcItems.forEach(dlcItem => {
                    const dlcName = dlcItem.querySelector('.dlc-name')?.textContent.toLowerCase() || '';
                    if (dlcName.includes(searchTerm)) {
                        dlcMatches = true;
                    }
                });
                
                // Show/hide card based on matches
                if (!searchTerm || gameMatches || dlcMatches) {
                    card.style.display = 'block';
                    visibleCount++;
                } else {
                    card.style.display = 'none';
                }
            });
            
            // Update search results summary
            const dlcsSummary = document.getElementById('dlcs-summary');
            if (dlcsSummary && searchTerm) {
                dlcsSummary.innerHTML = `<i class="fas fa-search"></i> ${visibleCount} result${visibleCount === 1 ? '' : 's'} for "${searchTerm}"`;
            } else if (!searchTerm) {
                updateDLCCount(); // Reset to normal count
            }
        }


        // Add event listeners for DLC functionality when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Prevent menu closing when clicking inside menu
            document.addEventListener('click', function(event) {
                if (event.target.closest('.action-menu') || event.target.closest('.dlc-item-menu')) {
                    event.stopPropagation();
                }
            });
            
            // Initialize DLC counts
            updateDLCCount();
            
            // Add keyboard support
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    closeAllDLCMenus();
                }
            });
            
            // Initialize lazy loading for thumbnails
            const thumbnails = document.querySelectorAll('.game-thumbnail');
            thumbnails.forEach(thumbnail => {
                thumbnail.addEventListener('error', function() {
                    this.src = 'https://via.placeholder.com/64x36/1a1a1a/666666?text=Game';
                });
            });
        });

        // API Integration Functions
        async function loadDLCsFromAPI() {
            const dlcContainer = document.getElementById('dlc-cards-container');
            if (!dlcContainer) return;

            // Clear existing content
            dlcContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);"><i class="fas fa-spinner fa-spin"></i> Searching for installed DLCs...</div>';

            try {
                // Send request to C# backend to get installed DLCs from SteamTools.lua
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage('getInstalledDLCs');
                } else {
                    throw new Error('WebView2 communication not available');
                }
            } catch (error) {
                console.error('Error loading DLCs:', error);
                dlcContainer.innerHTML = `<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Error loading DLC data: ${error.message}</p></div>`;
            }
        }

        // Function to handle DLC data from C# backend
        function processDLCData(data) {
            console.log('Received DLC data from C# backend:', data);
            
            const dlcContainer = document.getElementById('dlc-cards-container');
            if (!dlcContainer) return;
            
            // Handle new data structure with multiple games
            if (data && data.games && Array.isArray(data.games)) {
                if (data.games.length === 0) {
                    dlcContainer.innerHTML = '<div class="empty-state-container"><i class="fas fa-puzzle-piece"></i><p>No DLCs found</p></div>';
                    return;
                }
                
                // Clear container
                dlcContainer.innerHTML = '';
                
                // Create cards for each game with DLCs
                data.games.forEach(game => {
                    createDLCCard(game);
                });
                
                updateDLCCount();
            } else {
                dlcContainer.innerHTML = '<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Error: Invalid DLC data format</p></div>';
            }
        }


        // Function to handle DLC errors from C# backend
        function processDLCError(errorMessage) {
            console.error('DLC error from C# backend:', errorMessage);
            
            const dlcContainer = document.getElementById('dlc-cards-container');
            if (dlcContainer) {
                dlcContainer.innerHTML = `<div class="empty-state"><i class="fas fa-exclamation-triangle"></i><p>Error loading DLC data: ${errorMessage}</p></div>`;
            }
        }

        function createDLCCard(gameData) {
            const dlcContainer = document.getElementById('dlc-cards-container');
            const gameId = gameData.game_id;
            const gameName = gameData.game_name;
            const dlcCount = gameData.dlc_count;
            const dlcs = gameData.dlc;

            // Get main game image (try to fetch from API or use a default)
            const gameImageUrl = `https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/${gameId}/capsule_231x87.jpg`;

            // Create DLC items HTML with install status
            let dlcItemsHTML = '';
            let installedCount = 0;
            
            dlcs.forEach(dlcInfo => {
                const dlcId = dlcInfo.id;
                const isInstalled = dlcInfo.installed === true;
                if (isInstalled) installedCount++;
                
                const statusClass = isInstalled ? 'installed' : '';
                
                dlcItemsHTML += `
                    <div class="dlc-item ${statusClass}" data-dlc-id="${dlcId}">
                        <span class="dlc-id">${dlcId}</span>
                        <span class="dlc-name">${dlcInfo.name}</span>
                        <button class="dlc-remove-btn" onclick="removeDLC('${dlcId}')" title="Remove DLC" style="margin: 0 auto; display: block;">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
            });
            
            // Use actual installed count from data or calculated count
            const totalInstalled = gameData.installed_count || installedCount;

            // Create the full DLC card
            const cardHTML = `
                <div class="dlc-card" data-game-id="${gameId}">
                    <div class="dlc-card-header" onclick="toggleDLCCard(this)">
                        <div class="game-info">
                            <img class="game-thumbnail" src="${gameImageUrl}" alt="${gameName}" loading="lazy" onerror="handleImageError(this)">
                            <div class="game-details">
                                <h3 class="game-name">${gameName}</h3>
                            </div>
                        </div>
                        <div class="card-controls">
                            <span class="dlc-count">${totalInstalled}/${dlcCount} DLCs</span>
                            <button class="action-toggle" onclick="toggleDLCActionMenu(event, 'dlc-action-menu-${gameId}')">
                                <i class="fas fa-ellipsis-v"></i>
                            </button>
                            <button class="expand-toggle">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                    </div>

                    <!-- DLC List (Initially Hidden) -->
                    <div class="dlc-list" id="dlc-list-${gameId}">
                        <div class="dlc-list-header">
                            <span class="dlc-col-id">ID</span>
                            <span class="dlc-col-name">Name</span>
                            <span class="dlc-col-actions">Actions</span>
                        </div>
                        ${dlcItemsHTML}
                    </div>

                    <!-- DLC Card Action Menu -->
                    <div class="action-menu" id="dlc-action-menu-${gameId}">
                        <div class="action-item danger" onclick="removeAllDLCs('${gameId}'); closeDLCActionMenu();">
                            <span>Remove All DLCs</span>
                            <i class="fas fa-trash"></i>
                        </div>
                        <div class="game-id-display">
                            <span class="game-id-label">Game ID:</span>
                            <span class="game-id-value">${gameId}</span>
                        </div>
                    </div>
                </div>
            `;

            dlcContainer.innerHTML += cardHTML;
            updateDLCCount();
        }


        // Refresh DLCs function
        function refreshDLCs() {
            const refreshBtn = document.querySelector('button[onclick="refreshDLCs()"]');
            const originalIcon = refreshBtn?.querySelector('i');

            // Add spinning animation
            if (originalIcon) {
                originalIcon.className = 'fas fa-sync-alt fa-spin';
            }

            // Update summary with loading state
            const dlcsSummary = document.getElementById('dlcs-summary');
            if (dlcsSummary) {
                dlcsSummary.classList.remove('no-dlcs');
                dlcsSummary.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> Refreshing DLCs...';
            }

            // Load fresh data from API
            loadDLCsFromAPI().then(() => {
                // Remove spinning animation
                if (originalIcon) {
                    originalIcon.className = 'fas fa-sync-alt';
                }

                // Clear search if active
                const searchInput = document.getElementById('dlc-search');
                if (searchInput && searchInput.value) {
                    searchInput.value = '';
                    searchDLCs();
                }

                console.log('DLCs refreshed from API');
            }).catch(() => {
                // Remove spinning animation on error
                if (originalIcon) {
                    originalIcon.className = 'fas fa-sync-alt';
                }
            });
        }

        // Initialize DLC count on page load
        updateDLCCount();
        
        // Load DLCs from API on page load
        loadDLCsFromAPI();
        
        console.log('DLC Manager initialized successfully');
        
        // DLC Removal Functions
        let pendingDLCAction = null;
        
        function removeDLC(dlcId) {
            showDLCConfirmationPopup(
                'Remove DLC', 
                `Are you sure you want to remove DLC ${dlcId}? This action cannot be undone.`, 
                `removeDLCConfirmed:${dlcId}`
            );
        }
        
        function showDLCConfirmationPopup(title, message, action) {
            const titleElement = document.getElementById('dlc-confirmation-title');
            const messageElement = document.getElementById('dlc-confirmation-message');
            
            titleElement.textContent = title;
            messageElement.textContent = message;
            
            pendingDLCAction = action;
            
            const popup = document.getElementById('dlc-confirmation-popup');
            popup.style.display = 'flex';
            
            document.addEventListener('keydown', closeDLCConfirmationOnEscape);
        }
        
        function hideDLCConfirmationPopup() {
            const popup = document.getElementById('dlc-confirmation-popup');
            popup.style.display = 'none';
            pendingDLCAction = null;
            
            document.removeEventListener('keydown', closeDLCConfirmationOnEscape);
        }
        
        function confirmDLCAction() {
            const currentAction = pendingDLCAction;
            
            hideDLCConfirmationPopup();
            
            if (currentAction && currentAction.startsWith('removeDLCConfirmed:')) {
                const dlcId = currentAction.split(':')[1];
                removeDLCConfirmed(dlcId);
            }
        }
        
        function removeDLCConfirmed(dlcId) {
            // Send message to C# backend to remove DLC
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage(`removeDLC:${dlcId}`);
            }
            
            // Remove DLC from UI immediately
            const dlcElement = document.querySelector(`[data-dlc-id="${dlcId}"]`);
            if (dlcElement) {
                dlcElement.remove();
                updateDLCCount();
            }
            
            console.log(`DLC ${dlcId} removed successfully`);
        }
        
        function closeDLCConfirmationOnEscape(event) {
            if (event.key === 'Escape') {
                hideDLCConfirmationPopup();
            }
        }

        // Premium Popup Functions
        function showPremiumPopup() {
            const popup = document.getElementById('premium-popup-overlay');
            if (popup) {
                popup.classList.add('show');
                // Add escape key listener
                document.addEventListener('keydown', closePremiumPopupOnEscape);
            }
        }

        function closePremiumPopup() {
            const popup = document.getElementById('premium-popup-overlay');
            if (popup) {
                popup.classList.remove('show');
                // Remove escape key listener
                document.removeEventListener('keydown', closePremiumPopupOnEscape);
            }
        }

        function closePremiumPopupOnEscape(event) {
            if (event.key === 'Escape') {
                closePremiumPopup();
            }
        }

        function openPremiumPage() {
            // Send message to C# to open premium page on website
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('open-premium');
            }
            closePremiumPopup();
        }

        // Check if user has premium access
        function userHasPremium() {
            // Check user plan from userAccountInfo
            if (userAccountInfo && userAccountInfo.plan) {
                const plan = userAccountInfo.plan.toLowerCase();
                return plan.includes('premium') || plan.includes('admin');
            }
            return false;
        }

        // Check if game is premium-only
        function isGamePremiumOnly(gameId) {
            // Check if game details indicate premium-only
            const cachedDetails = gameDetailsCache[gameId];
            if (cachedDetails && cachedDetails.premium_only === true) {
                return true;
            }
            return false;
        }

        // Game Warning Popup Functions
        let pendingGameData = null;
        let pendingGameIsUpdate = false; // Track if pending operation is an update

        function showGameWarningPopup(gameData, isUpdate = false) {
            try {
                console.log('showGameWarningPopup called with data:', gameData, 'isUpdate:', isUpdate);
                pendingGameData = gameData;
                pendingGameIsUpdate = isUpdate;
                const popup = document.getElementById('game-warning-popup-overlay');
                const noticesContainer = document.getElementById('warning-notices');
                const title = document.getElementById('warning-popup-title');
                const subtitle = document.getElementById('warning-popup-subtitle');

                console.log('Popup element:', popup);
                console.log('Notices container:', noticesContainer);

                if (!popup || !noticesContainer) {
                    console.error('Required elements not found!');
                    return;
                }

                // Clear previous notices
                noticesContainer.innerHTML = '';

            // Update title and subtitle
            if (gameData.noInfo) {
                title.textContent = 'No Game Information';
                subtitle.textContent = `Game ${gameData.gameName} (ID: ${gameData.gameId})`;

                // Add "no info" warning
                const noInfoNotice = document.createElement('div');
                noInfoNotice.className = 'warning-notice-item';
                noInfoNotice.innerHTML = `
                    <i class="fas fa-question-circle"></i>
                    <div class="warning-notice-content">
                        <div class="warning-notice-title">No API Information</div>
                        <div class="warning-notice-desc">This game is not in our database. We cannot verify compatibility.</div>
                    </div>
                `;
                noticesContainer.appendChild(noInfoNotice);
            } else {
                title.textContent = 'Compatibility Warning';
                subtitle.textContent = gameData.gameName;

                // Add DRM warning if present
                if (gameData.drmNotice && gameData.drmNotice.trim() !== '') {
                    const drmNotice = document.createElement('div');
                    drmNotice.className = 'warning-notice-item';
                    drmNotice.innerHTML = `
                        <i class="fas fa-shield-alt"></i>
                        <div class="warning-notice-content">
                            <div class="warning-notice-title">DRM Protection</div>
                            <div class="warning-notice-desc">${gameData.drmNotice}</div>
                        </div>
                    `;
                    noticesContainer.appendChild(drmNotice);
                }

                // Add Launcher warning if present
                if (gameData.extUserNotice && gameData.extUserNotice.trim() !== '') {
                    const launcherNotice = document.createElement('div');
                    launcherNotice.className = 'warning-notice-item';
                    launcherNotice.innerHTML = `
                        <i class="fas fa-rocket"></i>
                        <div class="warning-notice-content">
                            <div class="warning-notice-title">External Launcher Required</div>
                            <div class="warning-notice-desc">${gameData.extUserNotice}</div>
                        </div>
                    `;
                    noticesContainer.appendChild(launcherNotice);
                }
            }

                // Update button text based on operation type
                const addAnywayBtn = document.getElementById('warning-add-anyway-btn');
                if (addAnywayBtn) {
                    addAnywayBtn.textContent = isUpdate ? 'Update Anyway' : 'Add Anyway';
                }

                // Show popup
                console.log('About to show popup');
                popup.classList.add('show');
                document.addEventListener('keydown', closeGameWarningPopupOnEscape);
                console.log('Popup should now be visible');
            } catch (error) {
                console.error('Error in showGameWarningPopup:', error);
            }
        }

        function closeGameWarningPopup() {
            const popup = document.getElementById('game-warning-popup-overlay');
            if (popup) {
                popup.classList.remove('show');
                document.removeEventListener('keydown', closeGameWarningPopupOnEscape);
            }
            pendingGameData = null;
            pendingGameIsUpdate = false; // Reset update flag
            unblockAddButton();
        }

        function closeGameWarningPopupOnEscape(event) {
            if (event.key === 'Escape') {
                closeGameWarningPopup();
            }
        }

        function confirmAddGame() {
            if (!pendingGameData) return;

            // Save data to local variables BEFORE closing popup (which nulls pendingGameData)
            const gameId = pendingGameData.gameId;
            const includeDlc = pendingGameData.includeDlc;
            const isUpdate = pendingGameIsUpdate;

            closeGameWarningPopup();

            // Check if this is an update or add operation
            if (isUpdate) {
                // Send message to C# to update the game (bypass warnings)
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage(`forceUpdateGame:${gameId}`);
                }
            } else {
                // Send message to C# to add the game (bypass warnings)
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage(`forceAddGame:${gameId}:${includeDlc}`);
                }
            }
        }

        function openNoticeFAQ() {
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('open-notice-faq');
            }
        }

        // Rotating Banner Functions
        let currentBannerIndex = 0;
        let bannerRotationInterval = null;
        let bannerData = null;

        function fetchBannerData() {
            // Request banner data from backend
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage('getBannerData');
                console.log('Requested banner data from backend');
            } else {
                console.error('WebView not available');
                hideBanner();
            }
        }

        function updateBannerData(data) {
            try {
                if (data && data.enabled === true && data.banners && data.banners.length > 0) {
                    bannerData = data;
                    generateBannerHTML(data.banners);
                    showBanner();
                    initRotatingBanner();
                } else {
                    hideBanner();
                }
            } catch (error) {
                console.error('Failed to update banner data:', error);
                hideBanner();
            }
        }

        function generateBannerHTML(banners) {
            const bannerContainer = document.getElementById('rotating-banner');
            if (!bannerContainer) return;

            let slidesHTML = '';
            let dotsHTML = '<div class="banner-dots">';

            banners.forEach((banner, index) => {
                const isActive = index === 0 ? 'active' : '';

                // Create gradient from color1 to color2
                const gradient = `linear-gradient(135deg, ${banner.color1}, ${banner.color2})`;
                const shadowColor = hexToRgba(banner.color1, 0.4);

                slidesHTML += `
                    <div class="banner-slide ${isActive}" data-link="${banner.link}">
                        <div class="banner-icon" style="background: ${gradient}; box-shadow: 0 4px 12px ${shadowColor};">
                            <i class="${banner.icon}"></i>
                        </div>
                        <div class="banner-info">
                            <div class="banner-label">${banner.label}</div>
                            <div class="banner-name">${banner.name}</div>
                            <div class="banner-desc">${banner.description}</div>
                        </div>
                    </div>
                `;

                dotsHTML += `<span class="banner-dot ${isActive}" onclick="goToBanner(${index})"></span>`;
            });

            dotsHTML += '</div>';
            bannerContainer.innerHTML = slidesHTML + dotsHTML;
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function showBanner() {
            const container = document.getElementById('ad-banner-container');
            if (container) {
                container.style.display = '';
                container.classList.add('visible');
            }
        }

        function hideBanner() {
            const container = document.getElementById('ad-banner-container');
            if (container) {
                container.style.display = 'none';
                container.classList.remove('visible');
            }
        }

        function initRotatingBanner() {
            const banner = document.getElementById('rotating-banner');
            if (!banner) return;

            // Add click handler to banner
            banner.addEventListener('click', function(e) {
                // Don't open link if clicking dots
                if (e.target.closest('.banner-dot')) {
                    return;
                }

                const activeSlide = banner.querySelector('.banner-slide.active');
                if (activeSlide) {
                    const link = activeSlide.getAttribute('data-link');
                    if (link && window.chrome && window.chrome.webview) {
                        window.chrome.webview.postMessage(`open-url:${link}`);
                    }
                }
            });

            // Start rotation every 5 seconds
            bannerRotationInterval = setInterval(nextBanner, 5000);
        }

        function updateBannerDots() {
            const dots = document.querySelectorAll('.banner-dot');
            dots.forEach((dot, index) => {
                if (index === currentBannerIndex) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }

        function goToBanner(index) {
            const bannerSlides = document.querySelectorAll('.banner-slide');
            if (bannerSlides.length === 0) return;

            // Remove active class from current
            bannerSlides[currentBannerIndex].classList.remove('active');

            // Update index
            currentBannerIndex = index;

            // Add active class to new slide
            bannerSlides[currentBannerIndex].classList.add('active');

            // Update dots
            updateBannerDots();

            // Reset auto-rotation timer
            clearInterval(bannerRotationInterval);
            bannerRotationInterval = setInterval(nextBanner, 5000);
        }

        function nextBanner() {
            const bannerSlides = document.querySelectorAll('.banner-slide');
            if (bannerSlides.length === 0) return;

            // Remove active class from current
            bannerSlides[currentBannerIndex].classList.remove('active');

            // Move to next banner
            currentBannerIndex = (currentBannerIndex + 1) % bannerSlides.length;

            // Add active class to next
            bannerSlides[currentBannerIndex].classList.add('active');

            // Update dots
            updateBannerDots();
        }

        function previousBanner() {
            const bannerSlides = document.querySelectorAll('.banner-slide');
            if (bannerSlides.length === 0) return;

            // Remove active class from current
            bannerSlides[currentBannerIndex].classList.remove('active');

            // Move to previous banner
            currentBannerIndex = (currentBannerIndex - 1 + bannerSlides.length) % bannerSlides.length;

            // Add active class to previous
            bannerSlides[currentBannerIndex].classList.add('active');

            // Update dots
            updateBannerDots();

            // Reset auto-rotation timer
            clearInterval(bannerRotationInterval);
            bannerRotationInterval = setInterval(nextBanner, 5000);
        }

        // Custom tooltip functions for DRM/Launcher badges
        function showBadgeTooltip(e) {
            const tooltip = document.getElementById('badge-tooltip');
            const title = tooltip.querySelector('.badge-tooltip-title');
            const content = tooltip.querySelector('.badge-tooltip-content');

            if (tooltip && title && content) {
                const tooltipTitle = e.currentTarget.getAttribute('data-tooltip-title');
                const tooltipContent = e.currentTarget.getAttribute('data-tooltip-content');

                title.textContent = tooltipTitle;
                content.innerHTML = tooltipContent.replace(/<br>/g, '<br>');

                tooltip.classList.add('show');
                moveBadgeTooltip(e);
            }
        }

        function moveBadgeTooltip(e) {
            const tooltip = document.getElementById('badge-tooltip');
            if (tooltip && tooltip.classList.contains('show')) {
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
            }
        }

        function hideBadgeTooltip() {
            const tooltip = document.getElementById('badge-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
            }
        }
    </script>

    <!-- DLC Confirmation Popup -->
    <div id="dlc-confirmation-popup" class="popup-overlay" style="display: none;">
        <div class="popup-content">
            <div class="popup-header">
                <h3 id="dlc-confirmation-title">Confirm Action</h3>
                <button class="popup-close" onclick="hideDLCConfirmationPopup()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="popup-body">
                <div class="confirmation-message">
                    <i class="fas fa-exclamation-triangle" style="color: #f39c12; font-size: 24px; margin-right: 10px;"></i>
                    <span id="dlc-confirmation-message">Are you sure you want to proceed?</span>
                </div>
            </div>
            <div class="popup-footer">
                <button class="secondary-btn" onclick="hideDLCConfirmationPopup()">Cancel</button>
                <button class="danger-btn" id="dlc-confirm-button" onclick="confirmDLCAction()">
                    <i class="fas fa-trash-alt"></i> Remove
                </button>
            </div>
        </div>
    </div>
</body>
</html> 